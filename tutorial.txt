1.Создание необходимой проектной директории: локально(на моем компьютере) и удаленно(на githube).

2. Переходим в созданную диреторию(папку).
- команда перехода по папкам : cd(название папки)
- шаг назад cd ..
- перемещение по диску : название диска : (например, C:)

3. Создание вирутального окружения.
- python -m venv venv(последнее venv название моего окружения)

4. Активация\деактивация виртуальной среды.
- перехожу в папку Scripts
- venv\Scripts\activate
- отключение виртуальной среды : \deactivate

5. Создаю необходимые файлы: .gitignore, requirements.txt, README.md.

6. В файл .giignore помещаю следующие файлы: venv/, .idea/, db.sqlite3.

7. Создаю файл с необходимыми библеотеками(зависимости).
- pip freeze > requirements.txt
внутри файла лежат зависимости и их версии.

8. С помощью команды git init установил связь между локальным(моим компьютером) и удаленным(github) репозиторием.

9. Создали проект с использованием фреймфорка Django с помощью команды: django-admin startproject myportfolio_app . .

(myportfolio_app - это имя проекта, его можно менять)
точка в конце команды, позволит установить локально в папку, не создавая еще одну в таким же именем( проекта),
использовании команды без точки не будет ошибкой.

Выполнив команду по запуска проекта, у нас появится папка, внутри которой будет вложенная папка, с файлами пакета
конфигураций.
Вложенная папка : Это и есть конфигурационная папка проекта, где расположены основные настройки Django.
Файлы вложенной папки конфигурации:

1 - __init__.py:
Это пустой файл, который обозначает, что данная директория является Python-пакетом. Благодаря этому Python может
импортировать модули из этой папки.

2 - settings.py:
Основной файл настроек проекта.

3 - urls.py:
Здесь задается маршрутизация (URLs) проекта.
Содержит таблицу маршрутов, связывающих URL-адреса с соответствующими представлениями (views)

4 - wsgi.py:
Файл для настройки WSGI (Web Server Gateway Interface).
Используется для развертывания проекта на веб-серверах, таких как Gunicorn или uWSGI.

5 - asgi.py.:
Файл для настройки ASGI (Asynchronous Server Gateway Interface).
Используется для запуска асинхронных приложений Django.
Применяется при использовании серверов, поддерживающих асинхронные запросы, например, Daphne или Uvicorn.

10. Переходим в папку с названием проекта MyPortfolio(используем cd), ту самую где уже есть папка с конфигурациями
(настройками Django).

11. Запускаем наш сервер вебсервер с помощью команды: python manage.py runserver.
файл manage.py - важный инструмент в управлении проектом, через него мы запускаем сервер, применяем миграции, создаем
приложения, выполняем пользовательские команды (написаные нами в ходе работы над проектом).

12. После чего выполняться первые миграции, в терминале мы получим вывод информации об использовании Django, а также
ссылку в браузер на наш вебсервер. На странице в браузере, при корректном запуске увидим ракету и вывод информации:
The install worked successfully! Congratulations!

http://127.0.0.1:8000/ , разбирая эту строку в браузере стоит отметить:
- тип протокола http
- адрес локального хоста  127.0.0.1
- порт :8000, при запуске, после слова runserver, можно указать другой порт и страница будет отображена иначе(редко делают).

После запуска сервера, Django создаст файл БД, а именно db.sqlite3, он работает по умолчанию с нашим фреймворком, менять
БД на другую, конечно же можно!

13. Создадим приложение, которое будет отвечать за функционал портфолио(например, отображение проектов, статей и т.д.)
с помощтю команды: python manage.py startapp myportfolio(myportfolio - имя приложения)

14. В файле settings.py в папке проекта в коллекции INSTALLED_APPS, в конец списка вносим название приложения в виде
строковом формате для регистрации приложения, после его реализации.
- myportfolio_app.apps.MyportfolioAppConfig

15. Сделали добавление, коммит, пуш на github с помощью команд: git add ., git commit -m "Поднял проект на Джанго",
git push origin feature.

16. В модуле models.py создаю классы модели: Project, Article, Contact, которые наследуются от базового класса Model,
на базе которого и строятся модели.
class Project(models.Model):, class Article(models.Model):, class Contact(models.Model):.

Класс модели в Django — это основной компонент для работы с базой данных. Он используется для описания структуры данных
и логики, связанной с этими данными. По сути, модель в Django — это Python-класс, который наследуется от
django.db.models.Model, где каждый атрибут этого класса становится полем в таблице базы данных.

При работе с Django не стоит переживать о подключении к БД и ее закрытию, когда пользователь покидает сайт. Фреймворк
делает это автоматически. Нам лишь нужно, через модель взаимодействия выполнять команды API интерфейса, записывать,
считывать и обновлять данные.

По умолчанию Django сконфигурирован для работы с БД SQLite.

Подключение БД, выполняется через коллекцию DATABASES в файле settings.py.

Зачем нужен класс модели?

Класс модели позволяет:
1 - Определить структуру данных — описать, какие поля будут в таблице базы данных, их типы, ограничения, значения по
умолчанию.
2- Работать с данными через ORM — вместо написания SQL-запросов можно использовать Python-код для создания, чтения,
обновления и удаления данных.
3 - Инкапсулировать бизнес-логику — модель позволяет сосредоточить логику, связанную с данными, в одном месте, что
упрощает поддержку и развитие кода.

В Django уже импортирован пакет models, содержащий базовый класс Model, на базе которого и строятся модели.

17. В модуле models.py в классе Project создаем поля title(заголовок), description(описание), link(ссылка),
created_at(создано в).

18. В модуле models.py в классе Project в поле title ссылаемся на models.Model, в котором мы работаем и из него берем
класс CharField - строковое поле, для строк малого и большого размера, в котором есть дополнительные аргументы:
max_length - максимальная длина (в символах) поля. Устанавливаем параметр max_length равным 100.
title = models.CharField(max_length=100)

19. В модуле models.py в классе Project в поле description ссылаемся на models.Model, в котором мы работаем и из него
берем класс TextField - большое текстовое поле, без дополнительных параметров.
description = models.TextField()

20. В модуле models.py в классе Project в поле link ссылаемся на models.Model, в котором мы работаем и из него берем
класс URLField - CharField для URL(ссылки), с параметрами blank, null. Если blank=True - поле может быть пустым в наших
формах. По умолчанию используется значение False, что означает, что проверка формы Django заставит нас ввести значение.
Это часто используется с null = True, потому что если вы хотите разрешить пустые значения, вы также хотите, чтобы база
данных могла представлять их соответствующим образом.
link = models.URLField(blank=True, null=True)

21. В модуле models.py в классе Project в поле created_at ссылаемся на models.Model, в котором мы работаем и из него
берем класс - DateTimeField - дата и время, представленные в Python datetime.datetime экземпляром. Имеет несколько
дополнительных необязательных аргументов:

auto_now - автоматически устанавливать для поля значение «Сейчас» каждый раз при сохранении объекта. Полезно для отметок
времени «последнего изменения». Обратите внимание, что всегда используется текущая дата ; это не просто значение по
умолчанию, которое вы можете изменить.

auto_now_add - автоматически установить для поля значение «Сейчас» при первом создании объекта. Полезно для создания
отметок времени. Обратите внимание, что всегда используется текущая дата ; это не просто значение по умолчанию, которое
вы можете изменить. Таким образом, даже если вы установите значение для этого поля при создании объекта, оно будет
проигнорировано. Устанавливаем auto_now_add=True.
reated_at = models.DateTimeField(auto_now_add=True)

22. В модуле models.py в классе Project создаем метод def __str__(self) - специальным метод, предназначенный для
представления строкового представления объекта. Метод str() всегда возвращает что-что.
def __str__(self):
    return self.title

23. В модуле models.py в классе Article в поле title ссылаемся на models.Model, в котором мы работаем и из него берем
класс CharField - строковое поле, для строк малого и большого размера, в котором есть дополнительные аргументы:
max_length - максимальная длина (в символах) поля. Устанавливаем параметр max_length равным 100.
title = models.CharField(max_length=100)

24. В модуле models.py в классе Article в поле description ссылаемся на models.Model, в котором мы работаем и из него
берем класс TextField - большое текстовое поле, без дополнительных параметров.
description = models.TextField()

25. В модуле models.py в классе Article в поле created_at ссылаемся на models.Model, в котором мы работаем и из него
берем класс - DateTimeField - дата и время, представленные в Python datetime.datetime экземпляром. Имеет несколько
дополнительных необязательных аргументов:

auto_now - автоматически устанавливать для поля значение «Сейчас» каждый раз при сохранении объекта. Полезно для отметок
времени «последнего изменения». Обратите внимание, что всегда используется текущая дата ; это не просто значение по
умолчанию, которое вы можете изменить.

auto_now_add - автоматически установить для поля значение «Сейчас» при первом создании объекта. Полезно для создания
отметок времени. Обратите внимание, что всегда используется текущая дата ; это не просто значение по умолчанию, которое
вы можете изменить. Таким образом, даже если вы установите значение для этого поля при создании объекта, оно будет
проигнорировано. Устанавливаем auto_now_add=True.
created_at = models.DateTimeField(auto_now_add=True)

26. В модуле models.py в классе Article создаем метод def __str__(self) - специальным метод, предназначенный для
представления строкового представления объекта. Метод str() всегда возвращает что-что.
def __str__(self):
    return self.title

27. В модуле models.py в классе Contact в поле name ссылаемся на models.Model, в котором мы работаем и из него берем
класс CharField - строковое поле, для строк малого и большого размера, в котором есть дополнительные аргументы: первый -
max_length - максимальная длина (в символах) поля. Устанавливаем параметр max_length равным 100. Второй - verbose_name -
возможность перевести с иностранного языка на русккий в строковом формате имя
name = models.CharField(max_length=100, verbose_name='имя')

28. В модуле models.py в классе Contact в поле email ссылаемся на models.Model, в котором мы работаем и из него берем
класс EmailField - класс CharField, который проверяет, является ли значение действительным адресом электронной почты,
без дополнительных параметров.
email = models.EmailField()

29. В модуле models.py в классе Contact в поле message ссылаемся на models.Model, в котором мы работаем и из него
берем класс TextField - большое текстовое поле, без дополнительных параметров.
 message = models.TextField()

30. В модуле models.py в классе Contact в поле created_at ссылаемся на models.Model, в котором мы работаем и из него
берем класс - DateTimeField - дата и время, представленные в Python datetime.datetime экземпляром. Имеет несколько
дополнительных необязательных аргументов:

auto_now - автоматически устанавливать для поля значение «Сейчас» каждый раз при сохранении объекта. Полезно для отметок
времени «последнего изменения». Обратите внимание, что всегда используется текущая дата ; это не просто значение по
умолчанию, которое вы можете изменить.

auto_now_add - автоматически установить для поля значение «Сейчас» при первом создании объекта. Полезно для создания
отметок времени. Обратите внимание, что всегда используется текущая дата ; это не просто значение по умолчанию, которое
вы можете изменить. Таким образом, даже если вы установите значение для этого поля при создании объекта, оно будет
проигнорировано. Устанавливаем auto_now_add=True.
created_at = models.DateTimeField(auto_now_add=True)

31. В модуле models.py в классе Contact создаем метод def __str__(self) - специальным метод, предназначенный для
представления строкового представления объекта. Метод str() всегда возвращает что-что.
def __str__(self):
    return f"Сообщение от : {self.name}"

32. Перехожу в папку venv/scripts и активирую виртуальное окружение с помощью команды: activate (venv/scripts/activate).

33. В терминале перехожу в папку MyPortfolio(использую cd ..) и с помощью команды: python manage.py makemigrations
делаем миграции, для сохранения данных в базе данных(фиксация текущего состояния класса моделей).

34. В терминале с помощью команды: python manage.py migrate выполняем миграцию(сохранение) данных.

35. Сделали добавление, коммит, пуш на github с помощью команд: git add ., git commit -m "Создал классы моделей",
git push origin feature.

36. Перехожу в папку venv/scripts и активирую виртуальное окружение с помощью команды: activate (venv/scripts/activate).

37. В модуле urls.py в директории проекта MyPortfolio делаю импорт функции path и функции include из фреймворка django
из модуля urls.
from django.urls import path, include

Функция path() в Django используется для определения URL-маршрутов в файлах urls.py. Возвращает элемент для включения в
urlpatterns.

Функция include принимает полный путь импорта Python к другому модулю конфигурации URL, который будет «включен» сюда.

38. В модуле urls.py в директории проекта MyPortfolio в коллекции urlpatterns прописываем функцию path, в которой
передаем адрес основной страницы(по умолчанию пустая строка('')), далее используя функцию include(содержит urls
приложения) - в строковом формате передаем названием приложения myportfolio_app и передается urls(прокладывает маршрут к
папке приложения и файлу urls.py) и опциональным параметром в строковом формате с пространством имен название приложения
myportfolio_app.

path('', include('myportfolio_app.urls', namespace='myportfolio_app')),
путь, который принимает пустую строку, по пустой строке я буду получать данные, путь в приложении к файлу приложения
и оно будет называется именем приложения).

39. В модуле urls.py в директории приложения myportfolio_app создаю класс домашней страницы HomeView, который
наследуется от базового класса View.
class HomeView(View):

40. В модуле urls.py в директории приложения myportfolio_app реализую метод поведения получения get, который принимает
self - это каждый текущий пользователь, который обращается к приложению и request - запрос.
def get(self, request):

41. В модуле urls.py в директории приложения myportfolio_app в методе поведения получения get, делается возврат базового
класса HttpResponse, с помощью ключевого слова return, который принимает параметр в строковом формате.
return HttpResponse("Главная страница")
def get(self, request)
    return HttpResponse("Главная страница")

42. В модуле urls.py в директории приложения myportfolio_app создаю класс список проектов ProjectListView, который
наследуется от базового класса View.
class ProjectListView(View):

43. В модуле urls.py в директории приложения myportfolio_app реализую метод поведения получения get, который принимает
self - это каждый текущий пользователь, который обращается к приложению и request - запрос.
def get(self, request):

44. В модуле urls.py в директории приложения myportfolio_app в методе поведения получения get, делается возврат базового
класса HttpResponse, с помощью ключевого слова return, который принимает параметр в строковом формате.
return HttpResponse("Страница проектов")
def get(self, request):
    return HttpResponse("Страница проектов")

45. В модуле urls.py в директории приложения myportfolio_app создаю класс список статей ArticleListView, который
наследуется от базового класса View.
class ArticleListView(View):

46. В модуле urls.py в директории приложения myportfolio_app реализую метод поведения получения get, который принимает
self - это каждый текущий пользователь, который обращается к приложению и request - запрос.
def get(self, request):

47. В модуле urls.py в директории приложения myportfolio_app в методе поведения получения get, делается возврат базового
класса HttpResponse, с помощью ключевого слова return, который принимает параметр в строковом формате.
return HttpResponse("Здесь находятся статьи")
def get(self, request):
    return HttpResponse("Здесь находятся статьи")

48. В модуле urls.py в директории приложения myportfolio_app создаю класс контактов ContactView, который наследуется
от базового класса View.
class ContactView(View):

49. В модуле urls.py в директории приложения myportfolio_app реализую метод поведения получения get, который принимает
self - это каждый текущий пользователь, который обращается к приложению и request - запрос.
def get(self, request):

50. В модуле urls.py в директории приложения myportfolio_app в методе поведения получения get, делается возврат базового
класса HttpResponse, с помощью ключевого слова return, который принимает параметр в строковом формате.
return HttpResponse("Контакты")
def get(self, request):
    return HttpResponse("Контакты")

51. В директории myportfolio_app создаем файл с названием urls.py.

52. В модуле urls.py в директории приложения myportfolio_app делаю импорт функции path из фреймворка django и из модуля
urls.(маршруты из проекта)
from django.urls import path

53. В модуле urls.py в директории приложения myportfolio_app импортирую через точку классы представления view.(когда
файлы находятся в одном пакете(точка указывает только на текущую директорию).
from . import views

54. В модуле urls.py в директории приложения myportfolio_app создаем переменную app_name для задания пространства имен
в строковом формате.
app_name = 'myportfolio_app'

55. В модуле urls.py в директории приложения myportfolio_app создаем коллекцию(список) urlpatterns, в которой через
функцию пути path указываем маршрут(первый параметр пустая строка), второй параметр - из модуля views берем классы
HomeView, применяем метод as_view() - позволяет Django понять, что класс должен отображаться как функция(без этого
метода визуализация не произойдет), третий параметр - название url-файлов name с названием в строковом формате home.
path('', views.HomeView.as_view(), name='home')

56. В модуле urls.py в директории приложения myportfolio_app добавляем в коллекцию(список) urlpatterns, через функцию
пути path указываем маршрут(первый параметр 'projects'/), второй параметр - из модуля views берем классы
ProjectListView, применяем метод as_view() - позволяет Django понять, что класс должен отображаться как функция(без
этого метода визуализация не произойдет), третий  - название url-файлов name с названием в строковом формате projects.
path('projects/', views.ProjectListView.as_view(), name='projects'),

57. В модуле urls.py в директории приложения myportfolio_app добавляем в коллекцию(список) urlpatterns, через функцию
пути path указываем маршрут(первый параметр 'articles'/), второй параметр - из модуля views берем классы
ArticleListView, применяем метод as_view() - позволяет Django понять, что класс должен отображаться как функция(без
этого метода визуализация не произойдет), третий  - название url-файлов name с названием в строковом формате articles.
path('articles/', views.ArticleListView.as_view(), name='articles'),

58. В модуле urls.py в директории приложения myportfolio_app добавляем в коллекцию(список) urlpatterns, через функцию
пути path указывает маршрут(первый параметр 'contact'/), второй параметр - из модуля views берем классы
ContactView, применяем метод as_view() - позволяет Django понять, что класс должен отображаться как функция(без
этого метода визуализация не произойдет), третий  - название url-файлов name с названием в строковом формате contact.
path('contact/', views.ContactView.as_view(), name='contact'),

59. В терминале производим запуск сервера, с помощью команды: python manage.py runserver.

60. Сделали добавление, коммит, пуш на github с помощью команд: git add ., git commit -m "Добавил классы представления
и написал к ним маршруты", git push origin feature.

61. В директории приложения myportfolio_app создаю директорию, под названием templates - шаблоны.

62. В директории приложения myportfolio_app в директории templates создаю директорию, под названием myportfolio_app.

63. В директории приложения myportfolio_app в директории templates в директории myportfolio_app создаю html-файлы, под
названием: базовый base, домашняя страница home, проектов project, статей articles, контактов contact, добавления
проектов add_project, сведений о проекте project_detail. Шаблоны в этих файлах можно найти в интернете или сгенерировать
в любой нейросети.(делал в deepseek)

64. В модуле views.py в директории приложения myportfolio_app из фреймворка django и из модуля shortcuts импортирую
функции render и redirect.
from django.shortcuts import render, redirect

render используется для отрисовки HTML-шаблонов с передачей контекста.
redirect перенаправляет пользователя на другую страницу.

65. В модуле views.py в директории приложения myportfolio_app из фреймворка django и из модуля http импортирую базовый
класс HttpResponse, который используется для возврата HTTP-ответов.
from django.http import HttpResponse

66. В модуле views.py в директории приложения myportfolio_app из фреймворка django и из модуля views.generic импортирую
базовые классы для создания представлений (views) на основе классов:
View — базовый класс для создания представлений.
TemplateView — для отображения шаблонов.
ListView — для отображения списка объектов.
DetailView — для отображения деталей одного объекта.
CreateView — для создания новых объектов.
generic - базовые классы в django, они представляют общую функциональность для различных типов представлений.
from django.views.generic import View, TemplateView, ListView, DetailView, CreateView

67. В модуле views.py в директории приложения myportfolio_app из файла forms.py импортирую класс контакт формы
ContactForm.
from .forms import ContactForm

68. В модуле views.py в директории приложения myportfolio_app из файла models.py импортирую класс проектов Project и
статей Article.
from .models import Project, Article

69. В модуле views.py в директории приложения myportfolio_app из фреймворка django и из пакета contrib импортирую модуль
сообщение messages, который используется для передачи сообщений пользователю (например, уведомлений об успешном
выполнении действия).
from django.contrib import messages

70. В модуле views.py в директории приложения myportfolio_app создаю класс домашней страницы HomeView, который
наследуется от класса отображения шаблонов TemplateView.Это представление используется для отображения главной страницы.
class HomeView(TemplateView):

71. В модуле views.py в директории приложения myportfolio_app в классе домашней страницы HomeView, создаю переменную
имя шаблона template_name, с указанием шаблона 'myportfolio_app/home.html' в строковом формате, который будет
использоваться для отображения главной страницы.
template_name = 'myportfolio_app/home.html'

72. В модуле views.py в директории приложения myportfolio_app создаю класс отображения списка проектов ProjectListView,
который наследуется от класса отображения списка объектов ListView. Это представление используется для отображения
списка проектов.
class ProjectListView(ListView):

73. В модуле views.py в директории приложения myportfolio_app в классе отображения списка проектов ProjectListView,
создаю переменную модели model, в которой хранится данные для отображения модели проектов Project.
model = Project

74. В модуле views.py в директории приложения myportfolio_app в классе отображения списка проектов ProjectListView,
создаю переменную имя шаблона template_name, с указанием шаблона 'myportfolio_app/projects.html' в строковом формате,
который будет использоваться для списка проектов.
template_name = 'myportfolio_app/projects.html'

75. В модуле views.py в директории приложения myportfolio_app в классе отображения списка проектов ProjectListView,
создаю переменную контекстное имя объекта context_object_name, которая будет передаваться в шаблон, в этом шаблоне
можно будет обращаться к списку проектов через переменную projects.
context_object_name = 'projects'

76. В модуле views.py в директории приложения myportfolio_app в классе отображения списка проектов ProjectListView,
создаю переменную разбивки на страницы paginate_by, в которой будет указано количества объектов на одной странице при
пагинации. В данном случае на одной странице будет отображаться 5 проектов.
paginate_by = 5

77. В модуле views.py в директории приложения myportfolio_app создаю класс отображения деталей одного проекта
ProjectDetailView, который наследуется от класса отображения деталей одного объекта DetailView. Это представление
используется для отображения деталей одного проекта.
class ProjectDetailView(DetailView):

78. В модуле views.py в директории приложения myportfolio_app в классе отображения деталей одного проекта
ProjectDetailView, создаю переменную модели model, в которой хранится данные для отображения модели проектов Project.
model = Project

79. В модуле views.py в директории приложения myportfolio_app в классе отображения деталей одного проекта
ProjectDetailView, создаю переменную имя шаблона template_name, с указанием шаблона 'myportfolio_app/project_detail.html'
в строковом формате, который будет использоваться для отображения деталей проекта.
template_name = 'myportfolio_app/project_detail.html'

80. В модуле views.py в директории приложения myportfolio_app в классе отображения деталей одного проекта
ProjectDetailView, создаю переменную контекстное имя объекта context_object_name, которая будет передаваться в шаблон,
в этом шаблоне можно будет обращаться к проекту через переменную project.
context_object_name = 'project'

81. В модуле views.py в директории приложения myportfolio_app в классе отображения деталей одного проекта
ProjectDetailView, определяю метод поведения получения объекта get_object, который используется для получения объекта
проекта, принимающий параметр self - это каждый текущий пользователь, который обращается к приложению.
def get_object(self):

82. В модуле views.py в директории приложения myportfolio_app в классе отображения деталей одного проекта
ProjectDetailView, в методе поведения получения объекта get_object создаю начало блока try, который используется для
обработки исключений.
try:

83. В модуле views.py в директории приложения myportfolio_app в классе отображения деталей одного проекта
ProjectDetailView, в методе поведения получения объекта get_object в блоке try, с помощью ключевого слова return
возвращаю вызов метода get_object() родительского класса. Это делается с помощью ключевого слова super(), которое
позволяет обратиться к функциональности родительского класса, от которого наследуется текущий класс, и вызвать его
метод получения объекта.
return super().get_object()

84. В модуле views.py в директории приложения myportfolio_app в классе отображения деталей одного проекта
ProjectDetailView, в методе поведения получения объекта get_object если проект не существует, возникает исключение
Project.DoesNotExist.
except Project.DoesNotExist:

85. В модуле views.py в директории приложения myportfolio_app в классе отображения деталей одного проекта
ProjectDetailView, в методе поведения получения объекта get_object если проект не существует, пользователь получает
сообщение message.info с параметрами self, принимающий запрос request и в строковом формате 'Нет проектов'.
messages.info(self.request, 'Нет проектов')

86. В модуле views.py в директории приложения myportfolio_app в классе отображения деталей одного проекта
ProjectDetailView, в методе поведения получения объекта get_object, если проект не найден, пользователь перенаправляется
на страницу со списком проектов с сообщением "Нет проектов" с помощью функции redirect.
return redirect('myportfolio_app/projects')

87. В модуле views.py в директории приложения myportfolio_app создаю класс создание представления проекта
ProjectCreateView, который наследуется от базового класса CreateView - создания новых объектов.
class ProjectCreateView(CreateView):

88. В модуле views.py в директории приложения myportfolio_app в классе создание представления проекта ProjectCreateView,
создаю переменную модели model, в которой хранится данные для отображения модели проектов Project.
model = Project

89. В модуле views.py в директории приложения myportfolio_app в классе создание представления проекта ProjectCreateView,
создаю переменную имя шаблона template_name, с указанием шаблона 'myportfolio_app/add_project.html' в строковом формате,
который будет использоваться для отображения добавления проекта.
template_name = 'myportfolio_app/add_project.html'

90. В модуле views.py в директории приложения myportfolio_app в классе создание представления проекта ProjectCreateView,
создаю переменную полей модели fields, которые будут отображаться в форме создания проекта из класса Project коллекцией
- списком, в котором, в строковом формате будут содержаться название title и описание description.
fields = ["title", "description"]

91. В модуле views.py в директории приложения myportfolio_app создаю класс представления списка статей ArticleListView,
который наследуется от базового класса ListView - для отображения списка объектов.
class ArticleListView(ListView):

92. В модуле views.py в директории приложения myportfolio_app в классе представления списка статей ArticleListView,
создаю переменную модели model, в которой хранится данные для отображения модели статей Article.
model = Article

93. В модуле views.py в директории приложения myportfolio_app в классе представления списка статей ArticleListView,
создаю переменную имя шаблона template_name, с указанием шаблона myportfolio_app/articles.html' в строковом формате,
который будет использоваться для отображения статей.
template_name = 'myportfolio_app/articles.html'

94. В модуле views.py в директории приложения myportfolio_app в классе представления списка статей ArticleListView,
создаю переменную контекстное имя объекта context_object_name, которая будет передаваться в шаблон, в этом шаблоне можно
будет обращаться к статья через переменную articles.
context_object_name = 'articles'

95. В модуле views.py в директории приложения myportfolio_app в классе представления списка статей ArticleListView,
создаю переменную разбивки на страницы paginate_by, в которой будет указано количества объектов на одной странице при
пагинации. В данном случае на одной странице будет отображаться 5 проектов.
paginate_by = 5

96. В модуле views.py в директории приложения myportfolio_app создаю класс просмотр контактов ContactView, который
наследуется от базового класса View - для создания представлений.
class ContactView(View):

97. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, определяю метод
поведения получения get, который используется для обработки GET-запросов, принимающий параметр self - это каждый
текущий пользователь, который обращается к приложению запрос - request.
def get(self, request):

98. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, в методе
поведения получения get создаю экземпляр формы form на основе класса ContactForm.
form = ContactForm()

99. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, в методе
поведения получения get с помощью ключевого слова return возвращаем функцию render - строенная функция Django, которая
используется для рендеринга (отрисовки) HTML-шаблонов, с которая принимает аргументы: request — объект запроса, который
содержит информацию о текущем HTTP-запросе, template_name — путь к шаблону, который нужно отрисовать в строковом формате
'myportfolio_app/contact.html', словарь с данными, которые передаются в шаблон для динамического формирования
HTML-страницы.
return render(request, 'myportfolio_app/contact.html', {

100. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, в методе
поведения получения get в возврате return функции рендеринга render в контексте - словарь, который передает данные из
представления (view) в шаблон, в который передаются объекты: в качестве ключа используется переменная с именем формы
form — это экземпляр формы.
'form': form,

101. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, в методе
поведения получения get в возврате return функции рендеринга render в контексте - словарь, который передает данные из
представления (view) в шаблон, в который передаются объекты: в качестве ключа используется переменная success - это
флаг который указывает, была ли форма успешно отправлена установлена в значение False - что означает, что форма еще не
была успешно отправлена.
'success': False,
return render(request, 'myportfolio_app/contact.html', {
            'form': form,
            'success': False,
})

102. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, определяю метод
поведения пост post, который используется для обработки POST-запросов, принимающий параметр self - это каждый
текущий пользователь, который обращается к приложению и  запрос - request.
def post(self, request):

103. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, в методе
поведения пост post создаю экземпляр формы form на основе класса ContactForm, принимающий аргумент request.POST - это
объект, который содержит данные, отправленные пользователем через HTTP-запрос методом POST. Когда пользователь заполняет
форму на сайте и нажимает кнопку "Отправить", данные из формы передаются на сервер в виде POST-запроса.
form = ContactForm()

104. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, в методе
поведения пост post проверяем валидность данных с помощью метода is_valid() - корректно ли заполнены поля формы.
if form.is_valid():

105. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, в методе
поведения пост post в проверке валидности данных is_valid, если данные валидны, они сохраняются в базу данных.
form.save()

106. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, в методе
поведения пост post с помощью ключевого слова return возвращаем функцию render - строенная функция Django, которая
используется для рендеринга (отрисовки) HTML-шаблонов, с которая принимает аргументы: request — объект запроса, который
содержит информацию о текущем HTTP-запросе, template_name — путь к шаблону, который нужно отрисовать в строковом формате
'myportfolio_app/contact.html', словарь с данными, которые передаются в шаблон для динамического формирования
HTML-страницы.
return render(request, 'myportfolio_app/contact.html', {

107. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, в методе
поведения пост post в возврате return функции рендеринга render в контексте - словарь, который передает данные из
представления (view) в шаблон, в который передаются объекты: в качестве ключа используется переменная с именем формы
form — это экземпляр формы, а значение ContactForm().
'form': ContactForm(),

108. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, в методе
поведения пост post в возврате return функции рендеринга render в контексте - словарь, который передает данные из
представления (view) в шаблон, в который передаются объекты: в качестве ключа используется переменная success - это
флаг который указывает, была ли форма успешно отправлена установлена в значение True - что означает, что форма была
успешно отправлена.
'success': True,
return render(request, 'myportfolio_app/contact.html', {
                'form': ContactForm(),
                'success': True,
})

109. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, в методе
поведения пост post с помощью ключевого слова return возвращаем функцию render - строенная функция Django, которая
используется для рендеринга (отрисовки) HTML-шаблонов, с которая принимает аргументы: request — объект запроса, который
содержит информацию о текущем HTTP-запросе, template_name — путь к шаблону, который нужно отрисовать в строковом формате
'myportfolio_app/contact.html', словарь с данными, которые передаются в шаблон для динамического формирования
HTML-страницы.
return render(request, 'myportfolio_app/contact.html', {

110. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, в методе
поведения пост post в возврате return функции рендеринга render в контексте - словарь, который передает данные из
представления (view) в шаблон, в который передаются объекты: в качестве ключа используется переменная с именем формы
form — это экземпляр формы.
'form': form,

111. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, в методе
поведения пост post в возврате return функции рендеринга render в контексте - словарь, который передает данные из
представления (view) в шаблон, в который передаются объекты: в качестве ключа используется переменная success - это
флаг который указывает, была ли форма успешно отправлена установлена в значение False - что означает, что форма еще не
была успешно отправлена.
'success': False,
return render(request, 'myportfolio_app/contact.html', {
            'form': form,
            'success': False,
})

112. В модуле urls.py в директории приложения myportfolio_app добавляем в коллекцию(список) urlpatterns, через функцию
пути path указываем маршрут(первый параметр 'projects/<int:pk>' - динамический адрес, для просмотра всех проектов,
добавляем динамический параметр ввиде первичного ключа primary key), второй параметр - из модуля views берем классы
ProjectDetailView, применяем метод as_view() - позволяет Django понять, что класс должен отображаться как функция(без
этого метода визуализация не произойдет), третий - название url-файлов name с названием в строковом формате
project_detail.
path('projects/<int:pk>/', views.ProjectDetailView.as_view(), name='project_detail'),

113. В модуле urls.py в директории приложения myportfolio_app добавляем в коллекцию(список) urlpatterns, через функцию
пути path указываем маршрут(первый параметр 'add_project'/), второй параметр - из модуля views берем классы
ProjectCreateView, применяем метод as_view() - позволяет Django понять, что класс должен отображаться как функция(без
этого метода визуализация не произойдет), третий - название url-файлов name с названием в строковом формате add_project.
path('add_project/', views.ProjectCreateView.as_view(), name='add_project'),

114. В директории myportfolio_app создаем файл с названием forms.py.

115. В модуле forms.py в директории приложения myportfolio_app из фреймворка django импортирую модуль forms.
from django import forms

116. В модуле forms.py в директории приложения myportfolio_app из файла моделей models.py импортирую классы проектов
Project, статей Article, контактов Contact.
from .models import Project, Article, Contact

117. В модуле forms.py в директории приложения myportfolio_app создаю класс форма проектов ProjectForm, который
наследуется от модуля forms и из него берем модель формы ModelForm. Это специальный класс Django, который автоматически
создает форму на основе модели, которая будет связана с моделью Project.
class ProjectForm(forms.ModelForm):

118. В модуле forms.py в директории приложения myportfolio_app внутри класса фома проектов ProjectForm создаем вложенный
класс мета class Meta - будет служить как вложенный класс и как мета класс - хранилище информации для формы проектов.
Этот класс используется для указания метаданных, которые Django будет использовать для настройки формы. Внутри Meta мы
определяем, какая модель будет использоваться и какие поля будут включены в форму.
class Meta:

119. В модуле forms.py в директории приложения myportfolio_app в классе форма проектов ProjectForm во вложенном классе
мета class Meta создаем переменную модели model, в которой хранится данные из класса Project директории models.py. Форма
связана с моделью Project. Django автоматически создаст поля формы на основе полей модели.
model = Project

120. В модуле forms.py в директории приложения myportfolio_app в классе форма проектов ProjectForm во вложенном классе
мета class Meta создаем переменную полей fields - коллекция(список), в котором прописываются в строковом формате поля,
модели Project будут включены в форму - это поля названия title, описания description и ссылки link. Только эти поля
будут отображаться в форме и использоваться для создания или редактирования объекта.
fields = ['title', 'description', 'link']

121. В модуле forms.py в директории приложения myportfolio_app в классе форма проектов ProjectForm во вложенном классе
мета class Meta создаем переменную виджетов widgets для полей формы, содержащие данные в виде словаря. Виджеты — это
HTML-элементы, которые Django использует для отображения полей формы. Мы можем кастомизировать их, добавляя атрибуты,
CSS-классы, плейсхолдеры. Первым ключом будет название title в строковом формате, значение будет forms и класс TextInput.
Для поля title мы используем виджет TextInput, который создаст текстовое поле ввода. С помощью параметра attrs мы
добавляем атрибуты HTML-элемента. TextInput принимает параметр attrs в виде словаря, словарь принимает ключ в строковом
формате class, а значение "form-control" добавляет CSS-класс form-control, который может использоваться для стилизации.
Второй ключ placeholder в строковом формате, а значение будет в строковом формате Введите имя.
"placeholder": "Введите имя" добавляет плейсхолдер, который будет отображаться внутри поля, пока пользователь не начнет
ввод.

widgets = {
    "title": forms.TextInput(attrs={
        "class": "form-control", "placeholder": "Введите имя"
         }),

122. В модуле forms.py в директории приложения myportfolio_app в классе форма проектов ProjectForm во вложенном классе
мета class Meta в переменной виджетов widgets для полей формы, содержащие данные в виде словаря. Виджеты — это
HTML-элементы, которые Django использует для отображения полей формы. Мы можем кастомизировать их, добавляя атрибуты,
CSS-классы, плейсхолдеры. Первым ключом будет название description в строковом формате, значение будет forms и класс
Textarea. Для поля description мы используем виджет Textarea, который создаст текстовую область для ввода. С помощью
параметра attrs мы добавляем атрибуты HTML-элемента. Textarea принимает параметр attrs в виде словаря, словарь принимает
ключ в строковом формате class, а значение "form-control", обавляет CSS-класс form-control, который может использоваться
для стилизации. Второй ключ placeholder в строковом формате, а значение будет в строковом формате Введите описание.
"placeholder": "Введите описание" для отображения подсказки внутри текстовой области.
"description": forms.Textarea(attrs={
    "class": "form-control", "placeholder": "Введите описание"
})}

123. В модуле forms.py в директории приложения myportfolio_app создаю класс форма статей ArticleForm, который
наследуется от модуля forms и из него берем модель формы ModelForm. Это специальный класс Django, который автоматически
создает форму на основе модели, которая будет связана с моделью Project.
class ArticleForm(forms.ModelForm):

124. В модуле forms.py в директории приложения myportfolio_app внутри класса фома статей ArticleForm создаем вложенный
класс мета class Meta - будет служить как вложенный класс и как мета класс - хранилище информации для формы статей.
Этот класс используется для указания метаданных, которые Django будет использовать для настройки формы. Внутри Meta мы
определяем, какая модель будет использоваться и какие поля будут включены в форму.
class Meta:

125. В модуле forms.py в директории приложения myportfolio_app в классе форма статей ArticleForm во вложенном классе
мета class Meta создаем переменную модели model, в которой хранится данные из класса Article директории models.py. Форма
связана с моделью Article. Django автоматически создаст поля формы на основе полей модели.
model = Article

126. В модуле forms.py в директории приложения myportfolio_app в классе форма статей ArticleForm во вложенном классе
мета class Meta создаем переменную полей fields - коллекция(список), в котором прописываются в строковом формате поля,
модели Article будут включены в форму - это поля названия title, описания description. Только эти поля будут
отображаться в форме и использоваться для создания или редактирования объекта.
fields = ['title', 'description']

127.В модуле urls.py в директории приложения myportfolio_app добавляем в коллекцию(список) urlpatterns, через функцию
пути path указываем маршрут(первый параметр 'add_article'/), второй параметр - из модуля views берем классы
ArticleCreateView, применяем метод as_view() - позволяет Django понять, что класс должен отображаться как функция(без
этого метода визуализация не произойдет), третий - название url-файлов name с названием в строковом формате add_article.
path('add_article/', views.ArticleCreateView.as_view(), name='add_article'),

128. В модуле urls.py в директории приложения myportfolio_app добавляем в коллекцию(список) urlpatterns, через функцию
пути path указываем маршрут(первый параметр 'articles/<int:pk>/' - динамический адрес, для просмотра всех проектов,
добавляем динамический параметр ввиде первичного ключа primary key), второй параметр - из модуля views берем классы
ArticleDetailView, применяем метод as_view() - позволяет Django понять, что класс должен отображаться как функция(без
этого метода визуализация не произойдет), третий - название url-файлов name с названием в строковом формате
article_detail.
path('articles/<int:pk>/', views.ArticleDetailView.as_view(), name='article_detail'),

129. В модуле urls.py в директории приложения myportfolio_app добавляем в коллекцию(список) urlpatterns, через функцию
пути path указываем маршрут(первый параметр '404/' - динамический адрес, для обработки ошибки 404 - страница не найдена),
второй параметр - из модуля views берем класс-представление Custom404View, применяем метод as_view() - позволяет Django
понять, что класс должен отображаться как функция(без этого метода визуализация не произойдет), третий - название
url-файлов name с названием в строковом формате custom404.
path('404/', views.Custom404View.as_view(), name='custom404'),

130. В модуле urls.py в директории проекта MyPortfolio импортируем функцию render из django.shortcuts. Эта функция
используется для рендеринга HTML-шаблонов и передачи контекста (данных) в шаблон. Мы будем использовать ее для
отображения кастомной страницы 404.
from django.shortcuts import render

131. В модуле urls.py в директории проекта MyPortfolio импортируем модуля admin из django.contrib - строенное приложение
Django, которое предоставляет интерфейс администратора для управления вашей базой данных. Мы будем использовать его для
добавления маршрута к админке.
from django.contrib import admin

132. В модуле urls.py в директории проекта MyPortfolio мпортируем модуль views из django.contrib.auth и переименовываем
его в auth_views. Этот модуль содержит встроенные представления (views) для аутентификации пользователей, такие как вход,
выход, сброс пароля и т.д.
from django.contrib.auth import views as auth_views

133. В модуле urls.py в директории проекта MyPortfolio мпортируем модуль LogoutView из django.contrib.auth.views. Это
встроенное представление для выхода пользователя из системы. Мы будем использовать его для обработки запросов на выход.
from django.contrib.auth.views import LogoutView

134. В модуле urls.py в директории проекта MyPortfolio создаем кастомную функцию custom_404, которая принимает параметры
объект запроса request и exception исключение, которое вызвало ошибку 404.
def custom_404(request, exception):

135. В модуле urls.py в директории проекта MyPortfolio в функции custom_404 с помощью ключевого слова return возвращаем
рендерит шаблона render, принимающий параметры запроса request, myportfolio_app/404.html - html-файл отображения ошибки
404, возвращает его с HTTP-статусом 404.
return render(request, 'myportfolio_app/404.html', status=404)

136. В модуле urls.py в директории проекта MyPortfolio создаем переменную обработчик ошибки 404 handler404 и привязываем
нашу кастомную функцию custom_404 к обработчику ошибки 404. Теперь, когда пользователь попытается перейти на
несуществующую страницу, Django будет использовать нашу функцию для отображения кастомной страницы 404.
handler404 = custom_404

137. В модуле urls.py в директории проекта MyPortfolio в коллекции urlpatterns прописываем функцию path, в которой
передаем адрес для входа на основную страницу(маршрут для страницы входа /login/). Используем встроенное представление
LoginView из auth_views, принимающие параметры шаблона использования для отображения страницы входа
template_name='registration/login.html', и имя маршрута  которое можно использовать в шаблонах или коде для ссылки на
этот URL.
path('login/', auth_views.LoginView.as_view(template_name='registration/login.html'), name='login'),

138. В модуле urls.py в директории проекта MyPortfolio в коллекции urlpatterns прописываем функцию path, в которой
передаем адрес для выхода из системы(маршрут для выхода из страницы входа /logout/). Используем встроенное представление
LoginView из auth_views, и имя маршрута  которое можно использовать в шаблонах или коде для ссылки на этот URL.
path('logout/', LogoutView.as_view(), name='logout'),

139. В директории приложения myportfolio_app в директории templates в директории myportfolio_app создаю html-файлы, под
названием: 404, добавления статей add_article, сведений о статье article_detail. Шаблоны в этих файлах можно найти в
интернете или сгенерировать в любой нейросети.(делал в deepseek)

140. В модуле settings.py в директории проекта MyPortfolio создаю переменную LOGIN_URL для определения URL-адреса или
путь к странице входа (логина) в веб-приложении, которая содержит в строковом формате 'registration/login.html' - путь к
HTML-шаблону, который будет использоваться для отображения формы входа. Когда пользователь пытается получить доступ к
защищенной странице без авторизации, его перенаправят на этот URL.
LOGIN_URL = 'registration/login.html'

141. В модуле settings.py в директории проекта MyPortfolio создаю переменную LOGIN_REDIRECT_URL для указания URL, на
который будет перенаправлен пользователь после успешного входа в систему, которая содержит в строковом формате '/' - это
корневой URL сайта (обычно это главная страница). После успешного входа пользователь будет автоматически перенаправлен
на главную страницу.
LOGIN_REDIRECT_URL = '/'

142. В модуле settings.py в директории проекта MyPortfolio создаю переменную LOGOUT_REDIRECT_URL для указания URL на
который будет перенаправлен пользователь после выхода из системы (логаута), которая содержит в строковом формате '/' -
корневой URL сайта. После выхода пользователь будет автоматически перенаправлен на главную страницу.
LOGOUT_REDIRECT_URL = '/'

143. В модуле settings.py в директории проекта MyPortfolio создаю переменную ALLOWED_HOSTS - настройка в Django, которая
определяет список допустимых хостов (доменов или IP-адресов), которые могут обслуживать сайт. Это важная мера
безопасности, которая предотвращает атаки, такие как HTTP Host header attacks, содержащую в коллекции(список) только с
IP-адреса 127.0.0.1, который является локальным адресом (localhost). Если запрос приходит с любого другого хоста,
Django отклонит его.
ALLOWED_HOSTS = ['127.0.0.1']

144. В модуле settings.py в директории проекта MyPortfolio в переменной LANGUAGE_CODE в строковом формате изменяю язык
приложения на русский.
LANGUAGE_CODE = 'ru-ru'

145. В модуле settings.py в директории проекта MyPortfolio в переменной TIME_ZONE часовой пояс в строковом формате меняю
часовой пояс на Европу/Минск
TIME_ZONE = 'Europe/Minsk'

146. В модуле app.py в директории приложения myportfolio_app создаю переменную подробное имя verbose_name, в которой в
строковом формате указываю название моего проекта, которое будет отображать в админ-панели.
verbose_name = "Мой проект"

147. В модуле models.py в директории приложения myportfolio_app в классах проектов Project, статей Article, контактах
Contact в полях этих классов в параметры полей, в качестве второго параметра добавляю параметр подробное имя verbose_name
в строковом формате указываю поля в проекте, которые будут отображать в админ-панеле.
class Project(models.Model):
    title = models.CharField(max_length=100, verbose_name="проект")
    description = models.TextField(verbose_name="описание")
    link = models.URLField(blank=True, null=True, verbose_name="ссылка")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="дата создания")

class Article(models.Model):
    title = models.CharField(max_length=100, verbose_name="название")
    description = models.TextField(verbose_name="описание")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="дата создания")

class Contact(models.Model):
    name = models.CharField(max_length=100, verbose_name='имя')
    email = models.EmailField(verbose_name="email")
    message = models.TextField(verbose_name="сообщение")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="дата создания")

148. В модуле models.py в директории приложения myportfolio_app внутри классов проектов Project, статей Article, контактах
Contact создаю вложенный класс мета class Meta - используется для определения метаданных модели.
class Meta:

149. В модуле models.py в директории приложения myportfolio_app внутри вложенного класса мета class Meta создаю новые
переменные подробное имя verbose_name - человекочитаемое имя для одного объекта модели и имя во множественном числе
verbose_name_plural человекочитаемое имя для множества объектов модели.
verbose_name = "мои проект"
verbose_name_plural = "мои проекты"

verbose_name = "статья"
verbose_name_plural = "статьи"

verbose_name = "контакт"
verbose_name_plural = "контакты"

150. В модуле views.py в директории приложения myportfolio_app из django.contrib.auth.mixins импортируем LoginRequiredMixin.
Этот миксин используется для ограничения доступа к представлениям (views) только для авторизованных пользователей. Если
пользователь не авторизован, он будет перенаправлен на страницу входа.
from django.contrib.auth.mixins import LoginRequiredMixin

151. В модуле views.py в директории приложения myportfolio_app из django.http импортируем Http404 - это исключение,
которое вызывает ошибку 404 (страница не найдена).
from django.http import HttpResponse, Http404

152. В модуле views.py в директории приложения myportfolio_app из django.urls импортируем reverse_lazy - функция
используется для ленивого (отложенного) получения URL по имени маршрута. Она полезна, например, когда URL нужно получить
до того, как Django полностью загрузит все маршруты.
from django.urls import reverse_lazy

153. В модуле views.py в директории приложения myportfolio_app из файла forms.py импортируем формы, которые находятся в
текущей директории. Эти формы используются для обработки данных, введенных пользователем.
from .forms import ContactForm, ProjectForm, ArticleForm

154. В модуле views.py в директории приложения myportfolio_app создаем класс ProjectCreateView, который наследуется от
LoginRequiredMixin и CreateView.
class ProjectCreateView(LoginRequiredMixin, CreateView):

155. В модуле views.py в директории приложения myportfolio_app в классе ProjectCreateView создаем новую переменную класс
формы form_class, форма, которая будет использоваться для ввода данных.
form_class = ProjectForm

156. В модуле views.py в директории приложения myportfolio_app в классе ProjectCreateView создаем новую переменную
login_url, в которой в строковом формате будет указана URL для перенаправления неавторизованных пользователей.
login_url = '/login/'

157. В модуле views.py в директории приложения myportfolio_app в классе ProjectCreateView создаем метод поведения получения
успешного url get_success_url, принимающий параметр self. Этот метод возвращает URL для перенаправления после успешного
создания проекта на страницу проектов.
def get_success_url(self):
    return reverse_lazy('myportfolio_app:projects')

158. В модуле views.py в директории приложения myportfolio_app в классе ProjectDetailView создаем метод получения объекта
get_object,принимающий параметры self и queryset=None - используется для гибкости. Он позволяет передать кастомный набор
объектов (QuerySet), из которого будет извлекаться объект. Если queryset не передан (остается None), то по умолчанию
используется стандартный QuerySet для модели.
def get_object(self, queryset=None):

159. В модуле views.py в директории приложения myportfolio_app в классе ProjectDetailView в методе получения объекта
get_object получаем первичный ключ pk, self.kwargs.get('pk') - то обращение к словарю kwargs, который содержит именованные
аргументы, переданные в URL.
pk = self.kwargs.get('pk')

160. В модуле views.py в директории приложения myportfolio_app в классе ProjectDetailView в методе получения объекта
get_object используем констркцию try, в которую помещяем запрос к базе данных, который пытается найти объект модели
Project с указанным первичным ключом pk.
try:
    return Project.objects.get(pk=pk)
objects.get(pk=pk) — это метод Django ORM (Object-Relational Mapping), который выполняет запрос к базе данных и возвращает
объект, соответствующий указанному первичному ключу.

161. В модуле views.py в директории приложения myportfolio_app в классе ProjectDetailView в методе получения объекта
get_object после конструкции try обрабатываем исключения Project.DoesNotExist - если объект с указанным pk не найден в
базе данных, Django выбрасывает исключение Project.DoesNotExist. В этом случае код перехватывает это исключение и вместо
него выбрасывает исключение Http404, которое в Django используется для возврата страницы с ошибкой 404(страница не найдена).
except Project.DoesNotExist:
    raise Http404

162. В модуле views.py в директории приложения myportfolio_app в классе ProjectDetailView создаем метод get, который
который обрабатывает HTTP GET-запросы. В Django классы представлений (views) используют методы get, post, put, delete и
т.д. для обработки соответствующих HTTP-методов, принимает параметры self - ссылка на текущий экземпляр класса, request
— объект HttpRequest, который содержит информацию о запросе, *args и **kwargs — дополнительные аргументы, которые могут
быть переданы в метод. В Django они часто используются для передачи параметров из URL.
def get(self, request, *args, **kwargs):

163. В модуле views.py в директории приложения myportfolio_app в классе ProjectDetailView в методе get созадем блок для
обработки исключений. Если код внутри блока try вызывает исключение, выполнение переходит в блок except.
try:
    self.object = self.get_object()

Эта строка пытается получить объект, который будет отображаться на странице.

self.get_object() — метод, который обычно определен в классах Django, таких как DetailView. Он извлекает объект,
используя переданные параметры.
self.object — переменная, в которую сохраняется полученный объект. Этот объект будет доступен в шаблоне для отображения.

164. В модуле views.py в директории приложения myportfolio_app в классе ProjectDetailView в методе get в блоке except
ловим исключение Http404, которое возникает, если объект не найден.
except Http404:

165. В модуле views.py в директории приложения myportfolio_app в классе ProjectDetailView в методе get в блоке except
если объект не найден, эта строка добавляет сообщение для пользователя от message.info - часть Django-фреймворка для работы
с сообщениями. Сообщения могут быть отображены на следующей странице, которую увидит пользователь, принимающая запрос
request - объект запроса, который передается в систему сообщений и текст сообщания, который будет показан пользователю.
messages.info(request, "На данный момент проектов нет.")

165. В модуле views.py в директории приложения myportfolio_app в классе ProjectDetailView в методе get в блоке except
с помощью ключевого слова return после добавления сообщения выполняется перенаправление пользователя на другую страницу,
с помощью функции redirect - функция Django, которая перенаправляет пользователя на указанный URL, принимающая в качестве
параметра в строковом формате имя URL-шаблона, на который будет выполнен редирект.
return redirect('myportfolio_app:articles')

166. В модуле views.py в директории приложения myportfolio_app в классе ProjectDetailView в методе get в блоке except
с помощью ключевого слова return если объект успешно найден, выполнение продолжается в родительском классе вызова метода
get. Это стандартное поведение для обработки GET-запроса и отображения страницы с деталями объекта. Возвращается результат
выполнения этого метода, который обычно является HTTP-ответом (например, отрендеренный шаблон с данными объекта).
return super().get(request, *args, **kwargs)

167. Для класса ArticleDetailView пункты 158 - 166 аналогичны.

168. В модуле views.py в директории приложения myportfolio_app создаю класс пользовательский вид 404 Custom404View,
который наследует от базового класса View. Класс View предоставляет базовую функциональность для обработки HTTP-запросов
в Django. Этот класс будет использоваться для создания пользовательского представления (view) для обработки ошибки 404
(страница не найдена).
class Custom404View(View):

169. В модуле views.py в директории приложения myportfolio_app в классе пользовательского вида 404 Custom404View создаю
метод получения get, определяющий обработку HTTP-запроса типа GET, принимающих два параметра: self - ссылка на экземпляр
класса и request - объект запроса, который содержит информацию о запросе, сделанном пользователем.
def get(self, request):

170. В модуле views.py в директории приложения myportfolio_app в классе пользовательского вида 404 Custom404View в методе
получения get с помощью ключевого слова return возвращаю ответ на запрос, с помощью функции render -  используется для
рендеринга HTML-шаблона и возврата его в качестве HTTP-ответа, принимающая запрос request - объект запроса, и в строковом
формате путь к шаблону, который будет использоваться для отображения страницы и параметр, указывающий, что что HTTP-статус
ответа будет 404 (страница не найдена). Это важно для того, чтобы браузеры и поисковые системы понимали, что запрошенная
страница не существует.
return render(request, 'myportfolio_app/404.html', status=404)

171. В терминале прописываем команду для создания суперпользователя.
python manage.py createsuperuser

172. После ввода команды по созданию суперпользователя вводим имя пользователя, адрес электронной почты и надежный пароль.

173. В модуле admin.py в директории приложения myportfolio_app из файла models.py импортирую класс проектов Project и
статей Article, чтобы зарегистрировать их в админке.
from .models import Project, Article

174. В модуле admin.py в директории приложения myportfolio_app создаю новую переменную admin.site.site_header, хранящую
значение в строковом формате, для установки заголовка сайта админки. Это текст, который будет отображаться в верхней
части интерфейса администратора.
admin.site.site_header = "Мой проект"

175. В модуле admin.py в директории приложения myportfolio_app создаю новую переменную admin.site.site_title, хранящую
значение в строковом формате, для установки заголовка вкладки браузера для админки.
admin.site.site_title = "Проект Евгена"

176. В модуле admin.py в директории приложения myportfolio_app регистрирую модель проектов Project в админке с помощью
декоратора @admin.register.
@admin.register(Project)

177. В модуле admin.py в директории приложения myportfolio_app создаю класс администратор проектов ProjectAdmin, который
наседуется от класса admin.ModelAdmin - позволяет настроить отображение и поведение модели в админке.
class ProjectAdmin(admin.ModelAdmin):

178. В модуле admin.py в директории приложения myportfolio_app в классе ProjectAdmin создаю новую переменную отображение
списка list_display, хранящую данные в коллекции(кортеже) с указанием какие поля модели проектов Project будут
отображаться в списке объектов на странице админки. В данном случае это название title, описание description, ссылка link,
дата создания created_at.
list_display = ("title", "description", "link", "created_at")

179. В модуле admin.py в директории приложения myportfolio_app в классе ProjectAdmin создаю новую переменную поля поиска
search_fields, хранящую данные в коллекции(кортеж) для возможности поиска объектов модели Project по полю title.
В админке появится строка поиска, которая будет искать совпадения в этом поле.
search_fields = ("title",)

180. В модуле admin.py в директории приложения myportfolio_app в классе ProjectAdmin создаю новую переменную список
фильтров list_filter, хранящую данные в коллекции(кортеж) для фильтрации по полю created_at. В интерфейсе админки появится
боковая панель с фильтрами, позволяющая сортировать объекты по дате создания.
list_filter = ("created_at",)

181. В модуле admin.py в директории приложения myportfolio_app в классе ProjectAdmin создаю новую переменную порядок
ordering, хранящую данные в коллекции(кортеж) для сортировки объектов модели Project. Объекты будут отображаться в
порядке убывания даты создания (-created_at означает "от новых к старым").
ordering = ("-created_at",)

182. Для класса ArticleAdmin пункты 176 - 181 аналогичны.
@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    list_display = ("title", "description", "image", "created_at")
    search_fields = ("title",)
    list_filter = ("created_at",)
    ordering = ("-created_at",)

183. Для класса ContactAdmin пункты 176 - 181 аналогичны.
@admin.register(Contact)
class ContactAdmin(admin.ModelAdmin):
    list_display = ("name", "email", "message", "created_at")
    search_fields = ("name",)
    list_filter = ("created_at",)
    ordering = ("-created_at",)

184. В модуле settings.py в директории проекта MyPortfolio создаю новую переменную с названием url- адрес СМИ MEDIA_URL
это URL, по которому медиафайлы будут доступны в браузере, в которой в строковом формате хранится значение по умолчанию,
которое указывает,, что медиафайлы будут доступны по пути.
MEDIA_URL = '/media/'

185. В модуле settings.py в директории проекта MyPortfolio создаю новую переменную с названием корень медиа MEDIA_ROOT,
это путь к директории на файловой системе сервера, где Django будет сохранять загруженные файлы, в которой в строковом
формате хранится способ создать путь к папке media, находящейся в корневой директории проекта (BASE_DIR).
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

186. В проекте MyPortfolio создаем новую директорию под названием media.

187. В модуле settings.py в директории проекта MyPortfolio прописываем условие проверки включения режима отладки (DEBUG)
в настройках Django. Если DEBUG = True, это означает, что проект находится в режиме разработки, и Django будет обслуживать
медиафайлы самостоятельно.
if settings.DEBUG:

188. В модуле settings.py в директории проекта MyPortfolio в условии проверки включения режима отладки создаем новую
переменную список URL-шаблонов urlpatterns, которые Django использует для маршрутизации запросов, используем функцию
static, которая добавляет маршрут для обслуживания медиафайлов, принимающая параметры URL-префикс, по которому будут
доступны медиафайлы и путь к директории на сервере, где хранятся медиафайлы.
urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

189. В модуле models.py в директории приложения myportfolio_app в классе статей Article определяем поле изображение image,
предназначенное для хранения изображений, оно наследуется от models.ImageField, который является подклассом models.FileField
и добавляет специфичные для изображений функции, такие как проверка на то, что загруженный файл является изображением,
принимающее параметр, указывающий директорию, в которую будут загружаться изображения, параметр позволяет полю быть
пустым при заполнении формы. Если blank=True, то пользователь может не загружать изображение, параметр позволяет полю
иметь значение NULL в базе данных. Если null=True, то в базе данных это поле может быть пустым (необязательным),
параметр задает человекочитаемое имя для поля, которое будет отображаться в административной панели Django и в формах.
image = models.ImageField(upload_to='articles/', blank=True, null=True, verbose_name='изображение')

190. В терминале(командной строке) выполняем миграции, с помощью команды python manage.py makemigrations, для сохранения
данных в базе данных.
python manage.py makemigrations
python manage.py migrate

191. В приложении myportfolio_app создаем новый модуль под названием middleware

192. В модуле.py settings.py в директории проекта MyPortfolio в коллекции MIDDLEWARE в строковом формате добавляем название
приложения myportfolio_app, далее middleware, а затем класс LoggingMiddleware, который, занимается логированием
(записью информации о запросах, ответах или других событиях в лог-файл).
'myportfolio_app.middleware.LoggingMiddleware',

MIDDLEWARE — это список middleware-компонентов, которые используются в веб-приложении на Django.
Middleware — это промежуточный слой, который обрабатывает запросы и ответы в процессе их прохождения через приложение.
Каждый middleware выполняет определённые действия до или после обработки запроса view-функцией.

193. В модуле middleware.py импортируем модуль time, который предоставляет функции для работы со временем. В данном случае
он будет использоваться для измерения времени выполнения запроса.
import time

194. В модуле middleware.py импортируем модуль logging, который позволяет настраивать логирование (запись информации о
работе программы). Это полезно для отслеживания событий, ошибок и другой информации.
import logging

195. В модуле middleware.py в директории приложения myportfolio_app создаем новую переменную логгер logger, в которую
передаем вызов метода getLogger из модуля logging. Метод getLogger используется для получения объекта логгера с именем,
передаем имя логгера. Имя логгера используется для идентификации логгера в системе логирования. Если логгер с таким именем
уже существует, метод getLogger вернет существующий объект логгера. Если логгер с таким именем еще не создан, метод создаст
новый логгер с этим именем.
logger = logging.getLogger('project_logger')

196. В модуле middleware.py в директории приложения myportfolio_app создаем класс LoggingMiddleware, который будет
использоваться как middleware в Django. Middleware — это компонент, который обрабатывает запросы и ответы в Django.
class LoggingMiddleware:

197. В модуле middleware.py в директории приложения myportfolio_app в классе LoggingMiddleware через строку документации
(docstring), описываем назначение класса. Она помогает другим разработчикам понять, что делает этот класс.
"""Класс обработки запросов и время их выполнения"""

198. В модуле middleware.py в директории приложения myportfolio_app в классе LoggingMiddleware с помощью ключевого слова
def создаем метод конструктора класса __init__ , принимающий параметры self и получения ответа get_response. Конструктор
вызывается при создании экземпляра класса.
def __init__(self, get_response):

199. В модуле middleware.py в директории приложения myportfolio_app в классе LoggingMiddleware в методе конструктора
__init__ сохраняем переданный аргумент get_response как атрибут экземпляра класса. get_response — это функция, которая
принимает запрос и возвращает ответ. Она передается middleware при его инициализации.
self.get_response = get_response

200. В модуле middleware.py в директории приложения myportfolio_app в классе LoggingMiddleware помощью ключевого слова
def создаем метод вызова __call__ , который делает экземпляр класса вызываемым. Этот метод вызывается при обработке
каждого запроса, принимающий параметры self и запрос request.
def __call__(self, request):

201. В модуле middleware.py в директории приложения myportfolio_app в классе LoggingMiddleware в методе вызова __call__
создаем новую переменную ip, в которую присвоим запрос request и из запроса берем метаданные META и из метаданных возьмем
метод get, который принимает параметры в строковом формате содержания IP-адреса клиента, отправившего запрос.
Извлекаем IP-адрес клиента из словаря request.META. Если IP-адрес недоступен, используется пустая строка.
ip = request.META.get('REMOTE_ADDR', '')

202. В модуле middleware.py в директории приложения myportfolio_app в классе LoggingMiddleware в методе вызова __call__
создаем новую переменную метод method, в которую присвоим получение HTTP-метода запроса(GET, POST) из объекта requset.
method = request.method

203. В модуле middleware.py в директории приложения myportfolio_app в классе LoggingMiddleware в методе вызова __call__
создаем новую переменную путь path, в которую присвоим получение пути запроса (URL) из объекта requset.
path = request.path

204. В модуле middleware.py в директории приложения myportfolio_app в классе LoggingMiddleware в методе вызова __call__
вызываем у логгера logger метод info, принимающий параметры в f-строке. Записываем в лог информацию о запросе, включая
метод, путь и IP-адрес. Уровень логирования info используется для записи обычных событий.
logger.info(f"Request: {method} {path} from {ip}")

205. В модуле middleware.py в директории приложения myportfolio_app в классе LoggingMiddleware в методе вызова __call__
создаем новую переменную время начала start_time для записи текущего времени, это начало отсчета времени выполнения запроса.
start_time = time.time()

206.  В модуле middleware.py в директории приложения myportfolio_app в классе LoggingMiddleware в методе вызова __call__
создаем новую переменную ответа response, которая передается в middleware при его инициализации. Она представляет собой
цепочку middleware и конечный view, который обрабатывает запрос, принимающая параметр бъект запроса, который содержит
информацию о HTTP-запросе.
response = self.get_response(request)

207. В модуле middleware.py в директории приложения myportfolio_app в классе LoggingMiddleware в методе вызова __call__
создаем новую переменную duration для вычисления продолжительности с момента выполнения.
duration = time.time() - start_time

208. В модуле middleware.py в директории приложения myportfolio_app в классе LoggingMiddleware в методе вызова __call__
у объекта для логирования используем метод для записи сообщений с уровнем логирования info, принимающая параметр ввиде
f-строки(форматированная строка), которая позволяет вставлять значения переменных напрямую в строку, method - HTTP-метод
запроса (GET, POST, PUT, DELETE), path - путь запроса, статус-код HTTP-ответа, время выполнения запросав секундах
logger.info(f"Response: {method} {path} - {response.status_code} took {duration:.2f} seconds")

209. В модуле middleware.py в директории приложения myportfolio_app в классе LoggingMiddleware в методе вызова __call__
с помощью ключевого слова return возвращаем HTTP-ответ клиенту.
return response

210. В директории проекта MyPortfolio создаем новую директории под названием logs, для хранения логов.

211. В модуле views.py в директории приложения myportfolio_app из модуля django.db.Model импортируем объект Q -
специальный объект, который позволяет создавать сложные SQL-запросы с использованием логических операторов (AND, OR, NOT).
from django.db.models import Q

212. В модуле views.py в директории приложения myportfolio_app в классе ProjectListView создаем метод get_queryset - это
метод, который используется в Django для получения набора данных (QuerySet), который будет использоваться для отображения
списка объектов, принимающий параметр self который, относится к экземпляру класса, в котором определен этот метод.
def get_queryset(self):

213. В модуле views.py в директории приложения myportfolio_app в классе ProjectListView в методе get_queryset создаем
новую переменную queryset, в которую мы сохраняем результат вызова метода get_queryset родительского клааса.
queryset = super().get_queryset()

214. В модуле views.py в директории приложения myportfolio_app в классе ProjectListView в методе get_queryset создаем
новую переменную query, в которую извлекаем значение параметра query из GET-запроса. Если параметр query не передан, то
по умолчанию будет использована пустая строка "". Это значение будет использоваться для фильтрации QuerySet.

215.В модуле views.py в директории приложения myportfolio_app в классе ProjectListView в методе get_queryset создаем
условие проверки, есть ли значение в переменной query. Если query не пустая строка, то выполняется блок кода внутри условия.
if query:

216. В модуле views.py в директории приложения myportfolio_app в классе ProjectListView в методе get_queryset в проверке
условия фильтруем QuerySet, используя метод filter, который позволяет отфильтровать объекты по определенным критериям.
Используется объект Q, который позволяет создавать сложные запросы с использованием логических операторов(| — лог. ИЛИ).
queryset = queryset.filter(

217. В модуле views.py в директории приложения myportfolio_app в классе ProjectListView в методе get_queryset в проверке
условия в фильтрации QuerySet ищет объекты, у которых поле title содержит строку query (без учета регистра) и ищет объекты,
у которых поле description содержит строку query (без учета регистра). Оператор |(ИЛИ) объединяет эти два условия, так
что объекты, удовлетворяющие любому из них, будут включены в результат.
Q(title__icontains=query) | Q(description__icontains=query)
)

218. В модуле views.py в директории приложения myportfolio_app в классе ProjectListView в методе get_queryset возвращаем
отфильтрованный (или неотфильтрованный, если query был пустым) QuerySet. Этот QuerySet будет использоваться для отображения
списка объектов в шаблоне.
return queryset

219. В модуле forms.py в директории приложения myportfolio_app создаем класс формы поиска SearchForm, который наследуется
от forms.Form. Классы форм в Django используются для создания HTML-форм и обработки данных, введенных пользователем.
class SearchForm(forms.Form):

220. В модуле forms.py в директории приложения myportfolio_app в классе формы поиска SearchForm создаем новую переменную
(поле) запроса query - будет использоваться для ввода текста, в которой ссылаемся на forms.Forms, из которого берем класс
CharField - строковое поле, для строк малого и большого размера, в котором есть дополнительные аргументы: max_length -
максимальная длина текста, которую можно ввести в это поле. Устанавливаем параметр max_length равным 255. Во второй параметр
указываем значение False - это поле не является обязательным для заполнения. Если required=True, то поле должно быть
заполнено, иначе форма не будет валидной. Задает метку (label) для поля, которая будет отображаться рядом с полем ввода
в HTML-форме, устанавливаем строковое значение "Поиск". Указываем, какой HTML-виджет будет использоваться для отображения
этого поля.
query = forms.CharField(max_length=255, required=False, label="Поиск", widget=forms.TextInput(attrs={

221. В модуле forms.py в директории приложения myportfolio_app в классе формы поиска SearchForm в переменной(поле) query
в HTML-виджете указываем атрибут HTML-тега <input>, который задает текст-подсказку, отображаемую внутри поля ввода, когда
оно пустое.
'placeholder': 'Поиск...',

222. В модуле forms.py в директории приложения myportfolio_app в классе формы поиска SearchForm в переменной(поле) query
в HTML-виджете указываем атрибут HTML-тега <input>, который добавляет CSS-класс form-control к полю ввода.
'class': 'form-control',

223. В модуле viewes.py в директории приложения myportfolio_app в классе ProjectListView создаем метод get_context_data
метод, который используется для добавления дополнительных данных в контекст шаблона, принимающий паремерты self и **kwargs
позволяет передавать в функцию произвольное количество именованных аргументов, а двойная звездочка (**) используется для
упаковки этих аргументов в словарь.
def get_context_data(self, **kwargs):

224. В модуле viewes.py в директории приложения myportfolio_app в классе ProjectListView в методе get_context_data создаем
новую переменную context, в которую положим результат вызова метода get_context_data родительского класса, чтобы получить
базовый контекст.
context = super().get_context_data(**kwargs)

225. В модуле views.py в директории приложения myportfolio_app импоритуем класс SearchForm из модуля forms.py
from .forms import SearchForm

226. В модуле views.py в директории приложения myportfolio_app в классе ProjectListView в методе get_context_data создаем
экземпляр формы SearchForm, который инициализируется данными из GET-запроса. Этот экземпляр формы добавляется в контекст
под ключом "form". Это позволяет использовать форму в шаблоне для отображения и обработки поискового запроса.
context["form"] = SearchForm(self.request.GET)

227. В модуле views.py в директории приложения myportfolio_app в классе ProjectListView в методе get_context_data
возвращаем обновленный контекст, который будет передан в шаблон для отображения.
return context

228. В модуле settings.py в директории проекта MyPortfolio создаем новую переменную EMAIL_BACKEND, в которой указываем,
какой бэкенд использовать для отправки электронной почты. В данном случае используется SMTP-бэкенд, который позволяет
отправлять письма через SMTP-сервер.
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'

229. В модуле settings.py в директории проекта MyPortfolio создаем новую переменную EMAIL_HOST, в которой указываем адрес
SMTP-сервера, которыйбудет использоваться для отправки почты. В данном случае это сервер Gmail.
EMAIL_HOST = 'smtp.gmail.com'

230. В модуле settings.py в директории проекта MyPortfolio создаем новую переменную EMAIL_PORT, в которой указываем порт,
который будет использоваться для подключения к SMTP-серверу. Порт 587 обычно используется для SMTP с TLS.
EMAIL_PORT = 587

231. В модуле settings.py в директории проекта MyPortfolio создаем новую переменную EMAIL_USE_TLS, в которой включаем
использование TLS (Transport Layer Security) для шифрования соединения с SMTP-сервером. Это важно для безопасности
передачи данных.
EMAIL_USE_TLS = True

232. В модуле settings.py в директории проекта MyPortfolio создаем новую переменную EMAIL_HOST_USER, в которой указываем
email-адрес, от имени которого будут отправляться письма. В данном случае это мой Gmail-адрес.
EMAIL_HOST_USER = 'zhenyagolenko92@gmail.com'

233. Заходим в google chrome, затем в google аккаунт, далее в раздел безопасность, в разделе вход в google ищем
двухэтапная аутентификация, затем пароли приложений и создаем приложение, совпадающее с названием нашего приложения.

234. В директории проекта MyPortfolio созлаем новый файл, под названием .env.

235. В файле .env создаем новую переменную EMAIL_HOST_PASSWORD, в которой хранится пароль от приложения.

236. В модуле settings.py в директории проекта MyPortfolio из молуля dotenv импортируем функцию load_dotenv.
from dotenv import load_dotenv

237. В модуле settings.py в директории проекта MyPortfolio вызываем функцию load_dotenv.
load_dotenv()

238. В модуле settings.py в директории проекта MyPortfolio создаем новую переменную EMAIL_HOST_PASSWORD, в которой
указываем пароль от email-адреса, указанного в EMAIL_HOST_USER. Пароль берется из переменной окружения, что является
хорошей практикой для безопасности.
EMAIL_HOST_PASSWORD = os.getenv('EMAIL_HOST_PASSWORD')

237. В модуле settings.py в директории проекта MyPortfolio создаем новую переменную CONTACT_EMAIL, в которой указываем
email-адрес, на который будут отправляться письма. В данном случае это адрес получателя.
CONTACT_EMAIL = 'ulia.maksimovich13@gmail.com'

239. В модуле views.py в директории приложения myportfolio_app импортирует функцию send_mail из Django, которая используется
для отправки электронной почты.
from django.core.mail import send_mail

240. В модуле views.py в директории приложения myportfolio_app создаем функцию для отправки тестовых писем send_test_email,
принимающая в качестве параметра запрос request, который обычно используется в Django для обработки HTTP-запросов.
def send_test_email(request):

241. В модуле views.py в директории приложения myportfolio_app в функции send_test_email создаем новую переменную тема
письма subject, которая содержит в строковом формате тему письма, которое будет отправлено.
subject = "Тестовое сообщение"

242. В модуле views.py в директории приложения myportfolio_app в функции send_test_email создаем новую переменную текст
письма message, которая содержит в строковом формате текст письма.
message = "Привет, проверка безопасности"

243. В модуле views.py в директории приложения myportfolio_app в функции send_test_email создаем новую переменную адрес
отправителя from_email, которая содержит адрес электронной почты, с которого будет отправлено письмо.
from_email = 'zhenyagolenko92@gmail.com'

244. В модуле views.py в директории приложения myportfolio_app в функции send_test_email создаем новую переменную адреса
получателей recipient_list, в которой содержит список адресов электронной почты, на которые будет отправлено письмо.
recipient_list = ['ulia.maksimovich13@gmail.com']

245. В модуле views.py в директории приложения myportfolio_app в функции send_test_email вызываем функцию send_mail,
которая отправляет электронное письмо. Функция принимает четыре аргумента: subject тема письма, message текст письма,
from_email адрес отправителя, recipient_list список адресов получателей.
send_mail(subject, message, from_email, recipient_list)

246. В модуле views.py в директории приложения myportfolio_app в функции send_test_email с помощью ключевого слово для возврата
return отправляем письмо. После отправки письма функция возвращает HTTP-ответ с текстом "Письмо отправлено". Это сообщение
будет отображено в браузере или другом клиенте, который сделал запрос к этой функции.
return HttpResponse("Письмо отправлено")

247. В модуле urls.py в директории приложения myportfolio_app добавляем в коллекцию(список) urlpatterns, через функцию
пути path указываем маршрут(первый параметр 'send_mail'/), второй параметр - из модуля views.py берем функцию send_test_email,
третий  - название url-файлов name с названием в строковом формате send_test_mail.
path('send_mail/', views.send_test_email, name='send_test_mail'),

248. В директории приложения myportfolio_app в директории templates в директории myportfolio_app создаю html-файлы, под
названием send_test_email.

249. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, в методе
поведения пост post в проверке валидности данных if form.is_valid() из очищенных данных формы (cleaned_data) извлекаются
значения полей name, email и message. Эти данные были проверены и очищены в процессе валидации формы.
name = form.cleaned_data['name']
email = form.cleaned_data['email']
message = form.cleaned_data['message']

250. В модуле views.py в директории приложения myportfolio_app из проекта(пакета) MyPortfolio импортирую модуль settings.
from MyPortfolio import settings

251. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, в методе
поведения пост post в проверке валидности данных if form.is_valid() начинается блок try, который предназначен для
обработки возможных исключений (ошибок) при отправке email. Вызывается функция send_mail, которая отправляет email, с
параметрами: subject тема письма, которая включает имя отправителя, message текст сообщения, который был введен
пользователем, from_email Email-адрес отправителя, который берется из настроек Django (settings.EMAIL_HOST_USER),
recipient_list список получателей, это email-адрес, указанный в настройках (settings.CONTACT_EMAIL), fail_silently если
False, то при ошибке отправки будет вызвано исключение.
try:
    send_mail(
        subject=f"Сообщение от : {name}",
        message=message,
        from_email=settings.EMAIL_HOST_USER,
        recipient_list=[settings.CONTACT_EMAIL],
        fail_silently=False,
        )


252. В модуле views.py в директории приложения myportfolio_app импортирую модуль traceback используется в Python для
извлечения, форматирования и вывода информации о стеке вызовов (stack trace) при возникновении исключений. Он полезен
для отладки, так как позволяет получить подробную информацию о том, где и почему произошла ошибка.
import traceback

253. В модуле views.py в директории приложения myportfolio_app в классе просмотра контактов ContactView, в методе
поведения пост post в проверке валидности данных if form.is_valid() если при отправке email произошла ошибка, выполнение
переходит в блок except, где обрабатывается исключение. В случае ошибки, с помощью traceback.format_exc() получается
полная трассировка ошибки, которая затем выводится в консоль. Это помогает в отладке.
except Exception as e:
    error_trace = traceback.format_exc()
    print(error_trace, e)

254. В терминале прописываем команду для установки зависимостей.
pip freeze > requirements.txt