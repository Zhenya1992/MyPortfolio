1.Создание необходимой проектной директории: локально(на моем компьютере) и удаленно(на githube).

2. Переходим в созданную диреторию(папку).
- команда перехода по папкам : cd(название папки)
- шаг назад cd ..
- перемещение по диску : название диска : (например, C:)

3. Создание вирутального окружения.
- python -m venv venv(последнее venv название моего окружения)

4. Активация\деактивация виртуальной среды.
- перехожу в папку Scripts
- venv\Scripts\activate
- отключение виртуальной среды : \deactivate

5. Создаю необходимые файлы: .gitignore, requirements.txt, README.md.

6. В файл .giignore помещаю следующие файлы: venv/, .idea/, db.sqlite3.

7. Создаю файл с необходимыми библеотеками(зависимости).
- pip freeze > requirements.txt
внутри файла лежат зависимости и их версии.

8. С помощью команды git init установил связь между локальным(моим компьютером) и удаленным(github) репозиторием.

9. Создали проект с использованием фреймфорка Django с помощью команды: django-admin startproject myportfolio_app . .

(myportfolio_app - это имя проекта, его можно менять)
точка в конце команды, позволит установить локально в папку, не создавая еще одну в таким же именем( проекта),
использовании команды без точки не будет ошибкой.

Выполнив команду по запуска проекта, у нас появится папка, внутри которой будет вложенная папка, с файлами пакета
конфигураций.
Вложенная папка : Это и есть конфигурационная папка проекта, где расположены основные настройки Django.
Файлы вложенной папки конфигурации:

1 - __init__.py:
Это пустой файл, который обозначает, что данная директория является Python-пакетом. Благодаря этому Python может
импортировать модули из этой папки.

2 - settings.py:
Основной файл настроек проекта.

3 - urls.py:
Здесь задается маршрутизация (URLs) проекта.
Содержит таблицу маршрутов, связывающих URL-адреса с соответствующими представлениями (views)

4 - wsgi.py:
Файл для настройки WSGI (Web Server Gateway Interface).
Используется для развертывания проекта на веб-серверах, таких как Gunicorn или uWSGI.

5 - asgi.py.:
Файл для настройки ASGI (Asynchronous Server Gateway Interface).
Используется для запуска асинхронных приложений Django.
Применяется при использовании серверов, поддерживающих асинхронные запросы, например, Daphne или Uvicorn.

10. Переходим в папку с названием проекта MyPortfolio(используем cd), ту самую где уже есть папка с конфигурациями
(настройками Django).

11. Запускаем наш сервер вебсервер с помощью команды: python manage.py runserver.
файл manage.py - важный инструмент в управлении проектом, через него мы запускаем сервер, применяем миграции, создаем
приложения, выполняем пользовательские команды (написаные нами в ходе работы над проектом).

12. После чего выполняться первые миграции, в терминале мы получим вывод информации об использовании Django, а также
ссылку в браузер на наш вебсервер. На странице в браузере, при корректном запуске увидим ракету и вывод информации:
The install worked successfully! Congratulations!

http://127.0.0.1:8000/ , разбирая эту строку в браузере стоит отметить:
- тип протокола http
- адрес локального хоста  127.0.0.1
- порт :8000, при запуске, после слова runserver, можно указать другой порт и страница будет отображена иначе(редко делают).

После запуска сервера, Django создаст файл БД, а именно db.sqlite3, он работает по умолчанию с нашим фреймворком, менять
БД на другую, конечно же можно!

13. Создадим приложение, которое будет отвечать за функционал портфолио(например, отображение проектов, статей и т.д.)
с помощтю команды: python manage.py startapp myportfolio(myportfolio - имя приложения)

14. В файле settings.py в папке проекта в коллекции INSTALLED_APPS, в конец списка вносим название приложения в виде
строковом формате для регистрации приложения, после его реализации.
- myportfolio_app.apps.MyportfolioAppConfig

15. Сделали добавление, коммит, пуш на github с помощью команд: git add ., git commit -m "Поднял проект на Джанго",
git push origin feature.

16. В модуле models.py создаю классы модели: Project, Article, Contact, которые наследуются от базового класса Model,
на базе которого и строятся модели.
class Project(models.Model):, class Article(models.Model):, class Contact(models.Model):.

Класс модели в Django — это основной компонент для работы с базой данных. Он используется для описания структуры данных
и логики, связанной с этими данными. По сути, модель в Django — это Python-класс, который наследуется от
django.db.models.Model, где каждый атрибут этого класса становится полем в таблице базы данных.

При работе с Django не стоит переживать о подключении к БД и ее закрытию, когда пользователь покидает сайт. Фреймворк
делает это автоматически. Нам лишь нужно, через модель взаимодействия выполнять команды API интерфейса, записывать,
считывать и обновлять данные.

По умолчанию Django сконфигурирован для работы с БД SQLite.

Подключение БД, выполняется через коллекцию DATABASES в файле settings.py.

Зачем нужен класс модели?

Класс модели позволяет:
1 - Определить структуру данных — описать, какие поля будут в таблице базы данных, их типы, ограничения, значения по
умолчанию.
2- Работать с данными через ORM — вместо написания SQL-запросов можно использовать Python-код для создания, чтения,
обновления и удаления данных.
3 - Инкапсулировать бизнес-логику — модель позволяет сосредоточить логику, связанную с данными, в одном месте, что
упрощает поддержку и развитие кода.

В Django уже импортирован пакет models, содержащий базовый класс Model, на базе которого и строятся модели.

17. В модуле models.py в классе Project создаем поля title(заголовок), description(описание), link(ссылка),
created_at(создано в).

18. В модуле models.py в классе Project в поле title ссылаемся на models.Model, в котором мы работаем и из него берем
класс CharField - строковое поле, для строк малого и большого размера, в котором есть дополнительные аргументы:
max_length - максимальная длина (в символах) поля. Устанавливаем параметр max_length равным 100.
title = models.CharField(max_length=100)

19. В модуле models.py в классе Project в поле description ссылаемся на models.Model, в котором мы работаем и из него
берем класс TextField - большое текстовое поле, без дополнительных параметров.
description = models.TextField()

20. В модуле models.py в классе Project в поле link ссылаемся на models.Model, в котором мы работаем и из него берем
класс URLField - CharField для URL(ссылки), с параметрами blank, null. Если blank=True - поле может быть пустым в наших
формах. По умолчанию используется значение False, что означает, что проверка формы Django заставит нас ввести значение.
Это часто используется с null = True, потому что если вы хотите разрешить пустые значения, вы также хотите, чтобы база
данных могла представлять их соответствующим образом.
link = models.URLField(blank=True, null=True)

21. В модуле models.py в классе Project в поле created_at ссылаемся на models.Model, в котором мы работаем и из него
берем класс - DateTimeField - дата и время, представленные в Python datetime.datetime экземпляром. Имеет несколько
дополнительных необязательных аргументов:

auto_now - автоматически устанавливать для поля значение «Сейчас» каждый раз при сохранении объекта. Полезно для отметок
времени «последнего изменения». Обратите внимание, что всегда используется текущая дата ; это не просто значение по
умолчанию, которое вы можете изменить.

auto_now_add - автоматически установить для поля значение «Сейчас» при первом создании объекта. Полезно для создания
отметок времени. Обратите внимание, что всегда используется текущая дата ; это не просто значение по умолчанию, которое
вы можете изменить. Таким образом, даже если вы установите значение для этого поля при создании объекта, оно будет
проигнорировано. Устанавливаем auto_now_add=True.
reated_at = models.DateTimeField(auto_now_add=True)

22. В модуле models.py в классе Project создаем метод def __str__(self) - специальным метод, предназначенный для
представления строкового представления объекта. Метод str() всегда возвращает что-что.
def __str__(self):
    return self.title

23. В модуле models.py в классе Article в поле title ссылаемся на models.Model, в котором мы работаем и из него берем
класс CharField - строковое поле, для строк малого и большого размера, в котором есть дополнительные аргументы:
max_length - максимальная длина (в символах) поля. Устанавливаем параметр max_length равным 100.
title = models.CharField(max_length=100)

24. В модуле models.py в классе Article в поле description ссылаемся на models.Model, в котором мы работаем и из него
берем класс TextField - большое текстовое поле, без дополнительных параметров.
description = models.TextField()

25. В модуле models.py в классе Article в поле created_at ссылаемся на models.Model, в котором мы работаем и из него
берем класс - DateTimeField - дата и время, представленные в Python datetime.datetime экземпляром. Имеет несколько
дополнительных необязательных аргументов:

auto_now - автоматически устанавливать для поля значение «Сейчас» каждый раз при сохранении объекта. Полезно для отметок
времени «последнего изменения». Обратите внимание, что всегда используется текущая дата ; это не просто значение по
умолчанию, которое вы можете изменить.

auto_now_add - автоматически установить для поля значение «Сейчас» при первом создании объекта. Полезно для создания
отметок времени. Обратите внимание, что всегда используется текущая дата ; это не просто значение по умолчанию, которое
вы можете изменить. Таким образом, даже если вы установите значение для этого поля при создании объекта, оно будет
проигнорировано. Устанавливаем auto_now_add=True.
created_at = models.DateTimeField(auto_now_add=True)

26. В модуле models.py в классе Article создаем метод def __str__(self) - специальным метод, предназначенный для
представления строкового представления объекта. Метод str() всегда возвращает что-что.
def __str__(self):
    return self.title

27. В модуле models.py в классе Contact в поле name ссылаемся на models.Model, в котором мы работаем и из него берем
класс CharField - строковое поле, для строк малого и большого размера, в котором есть дополнительные аргументы:
max_length - максимальная длина (в символах) поля. Устанавливаем параметр max_length равным 100.
name = models.CharField(max_length=100)

28. В модуле models.py в классе Contact в поле email ссылаемся на models.Model, в котором мы работаем и из него берем
класс EmailField - класс CharField, который проверяет, является ли значение действительным адресом электронной почты,
без дополнительных параметров.
email = models.EmailField()

29. В модуле models.py в классе Contact в поле message ссылаемся на models.Model, в котором мы работаем и из него
берем класс TextField - большое текстовое поле, без дополнительных параметров.
 message = models.TextField()

30. В модуле models.py в классе Contact в поле created_at ссылаемся на models.Model, в котором мы работаем и из него
берем класс - DateTimeField - дата и время, представленные в Python datetime.datetime экземпляром. Имеет несколько
дополнительных необязательных аргументов:

auto_now - автоматически устанавливать для поля значение «Сейчас» каждый раз при сохранении объекта. Полезно для отметок
времени «последнего изменения». Обратите внимание, что всегда используется текущая дата ; это не просто значение по
умолчанию, которое вы можете изменить.

auto_now_add - автоматически установить для поля значение «Сейчас» при первом создании объекта. Полезно для создания
отметок времени. Обратите внимание, что всегда используется текущая дата ; это не просто значение по умолчанию, которое
вы можете изменить. Таким образом, даже если вы установите значение для этого поля при создании объекта, оно будет
проигнорировано. Устанавливаем auto_now_add=True.
created_at = models.DateTimeField(auto_now_add=True)

31. В модуле models.py в классе Contact создаем метод def __str__(self) - специальным метод, предназначенный для
представления строкового представления объекта. Метод str() всегда возвращает что-что.
def __str__(self):
    return f"Сообщение от : {self.name}"

32. Перехожу в папку venv/scripts и активирую виртуальное окружение с помощью команды: activate (venv/scripts/activate).

33. В терминале перехожу в папку MyPortfolio(использую cd ..) и с помощью команды: python manage.py makemigrations
делаем миграции, для сохранения данных в базе данных(фиксация текущего состояния класса моделей).

34. В терминале с помощью команды: python manage.py migrate выполняем миграцию(сохранение) данных.

35. Сделали добавление, коммит, пуш на github с помощью команд: git add ., git commit -m "Создал классы моделей",
git push origin feature.

36. Перехожу в папку venv/scripts и активирую виртуальное окружение с помощью команды: activate (venv/scripts/activate).

37. В модуле urls.py в директории проекта MyPortfolio делаю импорт функции path и функции include из фреймворка django
из модуля urls.
from django.urls import path, include

Функция path() в Django используется для определения URL-маршрутов в файлах urls.py. Возвращает элемент для включения в
urlpatterns.

Функция include принимает полный путь импорта Python к другому модулю конфигурации URL, который будет «включен» сюда.

38. В модуле urls.py в директории проекта MyPortfolio в коллекции urlpatterns прописываем функцию path, в которой
передаем адрес основной страницы(по умолчанию пустая строка('')), далее используя функцию include(содержит urls
приложения) - в строковом формате передаем названием приложения myportfolio_app и передается urls(прокладывает маршрут к
папке приложения и файлу urls.py) и опциональным параметром в строковом формате с пространством имен название приложения
myportfolio_app.

path('', include('myportfolio_app.urls', namespace='myportfolio_app')),
путь, который принимает пустую строку, по пустой строке я буду получать данные, путь в приложении к файлу приложения
и оно будет называется именем приложения).


39. В модуле views.py в директории приложения myportfolio_app из фреймворка django и из модуля http импортирую базовый
класс HttpResponse.
from django.http import HttpResponse

40. В модуле views.py в директории приложения myportfolio_app из фреймворка django и из модуля views импортирую базовый
класс View.
from django.views import View

41. В модуле urls.py в директории приложения myportfolio_app создаю класс домашней страницы HomeView, который
наследуется от базового класса View.
class HomeView(View):

42. В модуле urls.py в директории приложения myportfolio_app реализую метод поведения получения get, который принимает
self - это каждый текущий пользователь, который обращается к приложению и request - запрос.
def get(self, request):

43. В модуле urls.py в директории приложения myportfolio_app в методе поведения получения get, делается возврат базового
класса HttpResponse, с помощью ключевого слова return, который принимает параметр в строковом формате.
return HttpResponse("Главная страница")
def get(self, request)
    return HttpResponse("Главная страница")

44. В модуле urls.py в директории приложения myportfolio_app создаю класс список проектов ProjectListView, который
наследуется от базового класса View.
class ProjectListView(View):

45. В модуле urls.py в директории приложения myportfolio_app реализую метод поведения получения get, который принимает
self - это каждый текущий пользователь, который обращается к приложению и request - запрос.
def get(self, request):

46. В модуле urls.py в директории приложения myportfolio_app в методе поведения получения get, делается возврат базового
класса HttpResponse, с помощью ключевого слова return, который принимает параметр в строковом формате.
return HttpResponse("Страница проектов")
def get(self, request):
    return HttpResponse("Страница проектов")

47. В модуле urls.py в директории приложения myportfolio_app создаю класс список статей ArticleListView, который
наследуется от базового класса View.
class ArticleListView(View):

48. В модуле urls.py в директории приложения myportfolio_app реализую метод поведения получения get, который принимает
self - это каждый текущий пользователь, который обращается к приложению и request - запрос.
def get(self, request):

49. В модуле urls.py в директории приложения myportfolio_app в методе поведения получения get, делается возврат базового
класса HttpResponse, с помощью ключевого слова return, который принимает параметр в строковом формате.
return HttpResponse("Здесь находятся статьи")
def get(self, request):
    return HttpResponse("Здесь находятся статьи")

50. В модуле urls.py в директории приложения myportfolio_app создаю класс контактов ContactView, который наследуется
от базового класса View.
class ContactView(View):

51. В модуле urls.py в директории приложения myportfolio_app реализую метод поведения получения get, который принимает
self - это каждый текущий пользователь, который обращается к приложению и request - запрос.
def get(self, request):

52. В модуле urls.py в директории приложения myportfolio_app в методе поведения получения get, делается возврат базового
класса HttpResponse, с помощью ключевого слова return, который принимает параметр в строковом формате.
return HttpResponse("Контакты")
def get(self, request):
    return HttpResponse("Контакты")

53. В директории myportfolio_app создаем файл с названием urls.py.

54. В модуле urls.py в директории приложения myportfolio_app делаю импорт функции path из фреймворка django и из модуля
urls.(маршруты из проекта)
from django.urls import path

55. В модуле urls.py в директории приложения myportfolio_app импортирую через точку классы представления view.(когда
файлы находятся в одном пакете(точка указывает только на текущую директорию).
from . import views

56. В модуле urls.py в директории приложения myportfolio_app создаем переменную app_name для задания пространства имен
в строковом формате.
app_name = 'myportfolio_app'

57. В модуле urls.py в директории приложения myportfolio_app создаем коллекцию(список) urlpatterns, в которой через
функцию пути path указываем маршрут(первый параметр пустая строка), второй параметр - из модуля views берем классы
HomeView, применяем метод as_view() - позволяет Django понять, что класс должен отображаться как функция(без этого
метода визуализация не произойдет), третий параметр - название url-файлов name с названием в строковом формате home.
path('', views.HomeView.as_view(), name='home')

58. В модуле urls.py в директории приложения myportfolio_app добавляем в коллекцию(список) urlpatterns, через функцию
пути path указываем маршрут(первый параметр 'projects'/), второй параметр - из модуля views берем классы
ProjectListView, применяем метод as_view() - позволяет Django понять, что класс должен отображаться как функция(без
этого метода визуализация не произойдет), третий  - название url-файлов name с названием в строковом формате projects.
path('projects/', views.ProjectListView.as_view(), name='projects'),

59. В модуле urls.py в директории приложения myportfolio_app добавляем в коллекцию(список) urlpatterns, через функцию
пути path указываем маршрут(первый параметр 'articles'/), второй параметр - из модуля views берем классы
ArticleListView, применяем метод as_view() - позволяет Django понять, что класс должен отображаться как функция(без
этого метода визуализация не произойдет), третий  - название url-файлов name с названием в строковом формате articles.
path('articles/', views.ArticleListView.as_view(), name='articles'),

60. В модуле urls.py в директории приложения myportfolio_app добавляем в коллекцию(список) urlpatterns, через функцию
пути path указывает маршрут(первый параметр 'contact'/), второй параметр - из модуля views берем классы
ContactView, применяем метод as_view() - позволяет Django понять, что класс должен отображаться как функция(без
этого метода визуализация не произойдет), третий  - название url-файлов name с названием в строковом формате contact.
path('contact/', views.ContactView.as_view(), name='contact'),

61. В терминале производим запуск сервера, с помощью команды: python manage.py runserver.

62. Сделали добавление, коммит, пуш на github с помощью команд: git add ., git commit -m "Добавил классы представления
и написал к ним маршруты", git push origin feature.