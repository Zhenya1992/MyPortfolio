1.Создание необходимой проектной директории: локально(на моем компьютере) и удаленно(на githube).

2. Переходим в созданную диреторию(папку).
- команда перехода по папкам : cd(название папки)
- шаг назад cd ..
- перемещение по диску : название диска : (например, C:)

3. Создание вирутального окружения.
- python -m venv venv(последнее venv название моего окружения)

4. Активация\деактивация виртуальной среды.
- перехожу в папку Scripts
- venv\Scripts\activate
- отключение виртуальной среды : \deactivate

5. Создаю необходимые файлы: .gitignore, requirements.txt, README.md.

6. В файл .giignore помещаю следующие файлы: venv/, .idea/, db.sqlite3.

7. Создаю файл с необходимыми библеотеками(зависимости).
- pip freeze > requirements.txt
внутри файла лежат зависимости и их версии.

8. С помощью команды git init установил связь между локальным(моим компьютером) и удаленным(github) репозиторием.

9. Создали проект с использованием фреймфорка Django с помощью команды: django-admin startproject myportfolio_app . .

(myportfolio_app - это имя проекта, его можно менять)
точка в конце команды, позволит установить локально в папку, не создавая еще одну в таким же именем( проекта),
использовании команды без точки не будет ошибкой.

Выполнив команду по запуска проекта, у нас появится папка, внутри которой будет вложенная папка, с файлами пакета
конфигураций.
Вложенная папка : Это и есть конфигурационная папка проекта, где расположены основные настройки Django.
Файлы вложенной папки конфигурации:

1 - __init__.py:
Это пустой файл, который обозначает, что данная директория является Python-пакетом. Благодаря этому Python может
импортировать модули из этой папки.

2 - settings.py:
Основной файл настроек проекта.

3 - urls.py:
Здесь задается маршрутизация (URLs) проекта.
Содержит таблицу маршрутов, связывающих URL-адреса с соответствующими представлениями (views)

4 - wsgi.py:
Файл для настройки WSGI (Web Server Gateway Interface).
Используется для развертывания проекта на веб-серверах, таких как Gunicorn или uWSGI.

5 - asgi.py.:
Файл для настройки ASGI (Asynchronous Server Gateway Interface).
Используется для запуска асинхронных приложений Django.
Применяется при использовании серверов, поддерживающих асинхронные запросы, например, Daphne или Uvicorn.

10. Переходим в папку с названием проекта MyPortfolio(используем cd), ту самую где уже есть папка с конфигурациями
(настройками Django).

11. Запускаем наш сервер вебсервер с помощью команды: python manage.py runserver.
файл manage.py - важный инструмент в управлении проектом, через него мы запускаем сервер, применяем миграции, создаем
приложения, выполняем пользовательские команды (написаные нами в ходе работы над проектом).

12. После чего выполняться первые миграции, в терминале мы получим вывод информации об использовании Django, а также
ссылку в браузер на наш вебсервер. На странице в браузере, при корректном запуске увидим ракету и вывод информации:
The install worked successfully! Congratulations!

http://127.0.0.1:8000/ , разбирая эту строку в браузере стоит отметить:
- тип протокола http
- адрес локального хоста  127.0.0.1
- порт :8000, при запуске, после слова runserver, можно указать другой порт и страница будет отображена иначе(редко делают).

После запуска сервера, Django создаст файл БД, а именно db.sqlite3, он работает по умолчанию с нашим фреймворком, менять
БД на другую, конечно же можно!

13. Создадим приложение, которое будет отвечать за функционал портфолио(например, отображение проектов, статей и т.д.)
с помощтю команды: python manage.py startapp myportfolio(myportfolio - имя приложения)

14. В файле settings.py в папке проекта в коллекции INSTALLED_APPS, в конец списка вносим название приложения в виде
строковом формате для регистрации приложения, после его реализации.
- myportfolio_app.apps.MyportfolioAppConfig

15. Сделали добавление, коммит, пуш на github с помощью команд: git add ., git commit -m "Поднял проект на Джанго",
git push origin feature.

16. В модуле models.py создаю классы модели: Project, Article, Contact, которые наследуются от базового класса Model,
на базе которого и строятся модели.
class Project(models.Model):, class Article(models.Model):, class Contact(models.Model):.

Класс модели в Django — это основной компонент для работы с базой данных. Он используется для описания структуры данных
и логики, связанной с этими данными. По сути, модель в Django — это Python-класс, который наследуется от
django.db.models.Model, где каждый атрибут этого класса становится полем в таблице базы данных.

При работе с Django не стоит переживать о подключении к БД и ее закрытию, когда пользователь покидает сайт. Фреймворк
делает это автоматически. Нам лишь нужно, через модель взаимодействия выполнять команды API интерфейса, записывать,
считывать и обновлять данные.

По умолчанию Django сконфигурирован для работы с БД SQLite.

Подключение БД, выполняется через коллекцию DATABASES в файле settings.py.

Зачем нужен класс модели?

Класс модели позволяет:
1 - Определить структуру данных — описать, какие поля будут в таблице базы данных, их типы, ограничения, значения по
умолчанию.
2- Работать с данными через ORM — вместо написания SQL-запросов можно использовать Python-код для создания, чтения,
обновления и удаления данных.
3 - Инкапсулировать бизнес-логику — модель позволяет сосредоточить логику, связанную с данными, в одном месте, что
упрощает поддержку и развитие кода.

В Django уже импортирован пакет models, содержащий базовый класс Model, на базе которого и строятся модели.

17. В модуле models.py в классе Project создаем поля title(заголовок), description(описание), link(ссылка),
created_at(создано в).

18. В модуле models.py в классе Project в поле title ссылаемся на models.Model, в котором мы работаем и из него берем
класс CharField - строковое поле, для строк малого и большого размера, в котором есть дополнительные аргументы:
max_length - максимальная длина (в символах) поля. Устанавливаем параметр max_length равным 100.

19. В модуле models.py в классе Project в поле description ссылаемся на models.Model, в котором мы работаем и из него
берем класс TextField - большое текстовое поле, без дополнительных параметров.

20. В модуле models.py в классе Project в поле link ссылаемся на models.Model, в котором мы работаем и из него берем
класс URLField - CharField для URL(ссылки), с параметрами blank, null. Если blank=True - поле может быть пустым в наших
формах. По умолчанию используется значение False, что означает, что проверка формы Django заставит нас ввести значение.
Это часто используется с null = True, потому что если вы хотите разрешить пустые значения, вы также хотите, чтобы база
данных могла представлять их соответствующим образом.

21. В модуле models.py в классе Project в поле created_at ссылаемся на models.Model, в котором мы работаем и из него
берем класс - DateTimeField - дата и время, представленные в Python datetime.datetime экземпляром. Имеет несколько
дополнительных необязательных аргументов:

auto_now - автоматически устанавливать для поля значение «Сейчас» каждый раз при сохранении объекта. Полезно для отметок
времени «последнего изменения». Обратите внимание, что всегда используется текущая дата ; это не просто значение по
умолчанию, которое вы можете изменить.

auto_now_add - автоматически установить для поля значение «Сейчас» при первом создании объекта. Полезно для создания
отметок времени. Обратите внимание, что всегда используется текущая дата ; это не просто значение по умолчанию, которое
вы можете изменить. Таким образом, даже если вы установите значение для этого поля при создании объекта, оно будет
проигнорировано. Устанавливаем auto_now_add=True.

22. В модуле models.py в классе Project создаем метод def __str__(self) - специальным метод, предназначенный для
представления строкового представления объекта. Метод str() всегда возвращает что-что.
def __str__(self):
    return self.title

23. В модуле models.py в классе Article в поле title ссылаемся на models.Model, в котором мы работаем и из него берем
класс CharField - строковое поле, для строк малого и большого размера, в котором есть дополнительные аргументы:
max_length - максимальная длина (в символах) поля. Устанавливаем параметр max_length равным 100.

24. В модуле models.py в классе Article в поле description ссылаемся на models.Model, в котором мы работаем и из него
берем класс TextField - большое текстовое поле, без дополнительных параметров.

25. В модуле models.py в классе Article в поле created_at ссылаемся на models.Model, в котором мы работаем и из него
берем класс - DateTimeField - дата и время, представленные в Python datetime.datetime экземпляром. Имеет несколько
дополнительных необязательных аргументов:

auto_now - автоматически устанавливать для поля значение «Сейчас» каждый раз при сохранении объекта. Полезно для отметок
времени «последнего изменения». Обратите внимание, что всегда используется текущая дата ; это не просто значение по
умолчанию, которое вы можете изменить.

auto_now_add - автоматически установить для поля значение «Сейчас» при первом создании объекта. Полезно для создания
отметок времени. Обратите внимание, что всегда используется текущая дата ; это не просто значение по умолчанию, которое
вы можете изменить. Таким образом, даже если вы установите значение для этого поля при создании объекта, оно будет
проигнорировано. Устанавливаем auto_now_add=True.

26. В модуле models.py в классе Article создаем метод def __str__(self) - специальным метод, предназначенный для
представления строкового представления объекта. Метод str() всегда возвращает что-что.
def __str__(self):
    return self.title

27. В модуле models.py в классе Contact в поле name ссылаемся на models.Model, в котором мы работаем и из него берем
класс CharField - строковое поле, для строк малого и большого размера, в котором есть дополнительные аргументы:
max_length - максимальная длина (в символах) поля. Устанавливаем параметр max_length равным 100.

28. В модуле models.py в классе Contact в поле email ссылаемся на models.Model, в котором мы работаем и из него берем
класс EmailField - класс CharField, который проверяет, является ли значение действительным адресом электронной почты,
без дополнительных параметров.

29. В модуле models.py в классе Contact в поле message ссылаемся на models.Model, в котором мы работаем и из него
берем класс TextField - большое текстовое поле, без дополнительных параметров.

30. В модуле models.py в классе Contact в поле created_at ссылаемся на models.Model, в котором мы работаем и из него
берем класс - DateTimeField - дата и время, представленные в Python datetime.datetime экземпляром. Имеет несколько
дополнительных необязательных аргументов:

auto_now - автоматически устанавливать для поля значение «Сейчас» каждый раз при сохранении объекта. Полезно для отметок
времени «последнего изменения». Обратите внимание, что всегда используется текущая дата ; это не просто значение по
умолчанию, которое вы можете изменить.

auto_now_add - автоматически установить для поля значение «Сейчас» при первом создании объекта. Полезно для создания
отметок времени. Обратите внимание, что всегда используется текущая дата ; это не просто значение по умолчанию, которое
вы можете изменить. Таким образом, даже если вы установите значение для этого поля при создании объекта, оно будет
проигнорировано. Устанавливаем auto_now_add=True.

31. В модуле models.py в классе Contact создаем метод def __str__(self) - специальным метод, предназначенный для
представления строкового представления объекта. Метод str() всегда возвращает что-что.
def __str__(self):
    return f"Сообщение от : {self.name}"

32. Перехожу в папку venv/scripts и активирую виртуальное окружение с помощью команды: activate (venv/scripts/activate).

33. В терминале перехожу в папку MyPortfolio(использую cd ..) и с помощью команды: python manage.py makemigrations
делаем миграции, для сохранения данных в базе данных(фиксация текущего состояния класса моделей).

34. В терминале с помощью команды: python manage.py migrate выполняем миграцию(сохранение) данных.

35. Сделали добавление, коммит, пуш на github с помощью команд: git add ., git commit -m "Создал классы моделей",
git push origin feature.

36. Перехожу в папку venv/scripts и активирую виртуальное окружение с помощью команды: activate (venv/scripts/activate).